import { distinctUntilChanged } from 'rxjs/operators';
import { safePluck } from '../utils/safe-pluck';
/**
 * @internal
 */
function defaultCompare(oldVal, newVal) {
    return oldVal === newVal;
}
/**
 * @description
 *
 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from
 * the previous item. Comparison will be done for each set key in the `keys` array.
 *
 * You can fine grain your distinct checks by providing a `KeyCompareMap` with those keys you want to compute
 * explicitly different
 *
 * The name `distinctUntilSomeChanged` was picked since it internally iterates over the `keys` and utilizes the
 * [some](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Array/some) method in order to
 * compute if values are distinct or not.
 *
 * @example
 *
 * import { of } from 'rxjs';
 * import { distinctUntilSomeChanged } from 'rx-angular/state';
 *
 * interface Person {
 *    age: number;
 *    name: string;
 * }
 *
 * of(
 *   { age: 4, name: 'Hans'},
 *   { age: 7, name: 'Sophie'},
 *   { age: 5, name: 'Han Solo'},
 *   { age: 5, name: 'HanSophie'},
 * ).pipe(
 *   distinctUntilSomeChanged(['age', 'name']),
 * )
 * .subscribe(x => console.log(x));
 *
 * // displays:
 * // { age: 4, name: 'Hans'}
 * // { age: 7, name: 'Sophie'}
 * // { age: 5, name: 'Han Solo'}
 * // { age: 5, name: 'HanSophie'}
 *
 * @example
 * // An example with `KeyCompareMap`
 * import { of } from 'rxjs';
 * import { distinctUntilSomeChanged } from 'rxjs/operators';
 *
 * interface Person {
 *     age: number;
 *     name: string;
 *  }
 * const customComparison: KeyCompareMap<Person> = {
 *   name: (oldName, newName) => oldName.substring(0, 2) === newName.substring(0, 2)
 * };
 *
 * of(
 *     { age: 4, name: 'Hans'},
 *     { age: 7, name: 'Sophie'},
 *     { age: 5, name: 'Han Solo'},
 *     { age: 5, name: 'HanSophie'},
 *   ).pipe(
 *     distinctUntilSomeChanged(['age', 'name'], customComparison),
 *   )
 *   .subscribe(x => console.log(x));
 *
 * // displays:
 * // { age: 4, name: 'Hans' }
 * // { age: 7, name: 'Sophie' }
 * // { age: 5, name: 'Han Solo' }
 *
 * @param {K[]} keys String key for object property lookup on each item.
 * @param {KeyCompareMap<T>} [keyCompareMap] Optional KeyCompareMap to explicitly define comparisons for some of the keys
 * @docsPage distinctUntilSomeChanged
 * @docsCategory operators
 */
export function distinctUntilSomeChanged(keys, keyCompareMap) {
    // default compare function applying === to every key
    let distinctCompare = (oldState, newState) => keys.some((key) => !defaultCompare(safePluck(oldState, [key]), safePluck(newState, [key])));
    // generate compare function respecting every case of provided keyCompareMap
    if (keyCompareMap !== undefined) {
        const compare = (key) => {
            return keyCompareMap.hasOwnProperty(key) &&
                keyCompareMap[key] !== undefined
                ? keyCompareMap[key]
                : defaultCompare;
        };
        distinctCompare = (oldState, newState) => {
            return keys.some((key) => !compare(key)(safePluck(oldState, [key]), safePluck(newState, [key])));
        };
    }
    return distinctUntilChanged((oldV, newV) => !distinctCompare(oldV, newV));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGlzdGluY3RVbnRpbFNvbWVDaGFuZ2VkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vbGlicy9zdGF0ZS9zZWxlY3Rpb25zL3NyYy9saWIvb3BlcmF0b3JzL2Rpc3RpbmN0VW50aWxTb21lQ2hhbmdlZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUV0RCxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFFaEQ7O0dBRUc7QUFDSCxTQUFTLGNBQWMsQ0FBSSxNQUFTLEVBQUUsTUFBUztJQUM3QyxPQUFPLE1BQU0sS0FBSyxNQUFNLENBQUM7QUFDM0IsQ0FBQztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXVFRztBQUNILE1BQU0sVUFBVSx3QkFBd0IsQ0FDdEMsSUFBUyxFQUNULGFBQWdDO0lBRWhDLHFEQUFxRDtJQUNyRCxJQUFJLGVBQWUsR0FBaUIsQ0FBQyxRQUFRLEVBQUUsUUFBUSxFQUFFLEVBQUUsQ0FDekQsSUFBSSxDQUFDLElBQUksQ0FDUCxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQ04sQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDLFFBQVEsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLFFBQVEsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FDMUUsQ0FBQztJQUVKLDRFQUE0RTtJQUM1RSxJQUFJLGFBQWEsS0FBSyxTQUFTLEVBQUUsQ0FBQztRQUNoQyxNQUFNLE9BQU8sR0FBRyxDQUFDLEdBQU0sRUFBRSxFQUFFO1lBQ3pCLE9BQU8sYUFBYSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUM7Z0JBQ3RDLGFBQWEsQ0FBQyxHQUFHLENBQUMsS0FBSyxTQUFTO2dCQUNoQyxDQUFDLENBQUUsYUFBYSxDQUFDLEdBQUcsQ0FBcUI7Z0JBQ3pDLENBQUMsQ0FBQyxjQUFjLENBQUM7UUFDckIsQ0FBQyxDQUFDO1FBQ0YsZUFBZSxHQUFHLENBQUMsUUFBUSxFQUFFLFFBQVEsRUFBRSxFQUFFO1lBQ3ZDLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FDZCxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQ04sQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsU0FBUyxDQUFDLFFBQVEsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLFFBQVEsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FDeEUsQ0FBQztRQUNKLENBQUMsQ0FBQztJQUNKLENBQUM7SUFDRCxPQUFPLG9CQUFvQixDQUFDLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQyxlQUFlLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDNUUsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1vbm9UeXBlT3BlcmF0b3JGdW5jdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZGlzdGluY3RVbnRpbENoYW5nZWQgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBDb21wYXJlRm4sIEtleUNvbXBhcmVNYXAgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2luZGV4JztcbmltcG9ydCB7IHNhZmVQbHVjayB9IGZyb20gJy4uL3V0aWxzL3NhZmUtcGx1Y2snO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBkZWZhdWx0Q29tcGFyZTxUPihvbGRWYWw6IFQsIG5ld1ZhbDogVCk6IGJvb2xlYW4ge1xuICByZXR1cm4gb2xkVmFsID09PSBuZXdWYWw7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgYWxsIGl0ZW1zIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHRoYXQgYXJlIGRpc3RpbmN0IGJ5IGNvbXBhcmlzb24gZnJvbVxuICogdGhlIHByZXZpb3VzIGl0ZW0uIENvbXBhcmlzb24gd2lsbCBiZSBkb25lIGZvciBlYWNoIHNldCBrZXkgaW4gdGhlIGBrZXlzYCBhcnJheS5cbiAqXG4gKiBZb3UgY2FuIGZpbmUgZ3JhaW4geW91ciBkaXN0aW5jdCBjaGVja3MgYnkgcHJvdmlkaW5nIGEgYEtleUNvbXBhcmVNYXBgIHdpdGggdGhvc2Uga2V5cyB5b3Ugd2FudCB0byBjb21wdXRlXG4gKiBleHBsaWNpdGx5IGRpZmZlcmVudFxuICpcbiAqIFRoZSBuYW1lIGBkaXN0aW5jdFVudGlsU29tZUNoYW5nZWRgIHdhcyBwaWNrZWQgc2luY2UgaXQgaW50ZXJuYWxseSBpdGVyYXRlcyBvdmVyIHRoZSBga2V5c2AgYW5kIHV0aWxpemVzIHRoZVxuICogW3NvbWVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RlL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NvbWUpIG1ldGhvZCBpbiBvcmRlciB0b1xuICogY29tcHV0ZSBpZiB2YWx1ZXMgYXJlIGRpc3RpbmN0IG9yIG5vdC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGltcG9ydCB7IG9mIH0gZnJvbSAncnhqcyc7XG4gKiBpbXBvcnQgeyBkaXN0aW5jdFVudGlsU29tZUNoYW5nZWQgfSBmcm9tICdyeC1hbmd1bGFyL3N0YXRlJztcbiAqXG4gKiBpbnRlcmZhY2UgUGVyc29uIHtcbiAqICAgIGFnZTogbnVtYmVyO1xuICogICAgbmFtZTogc3RyaW5nO1xuICogfVxuICpcbiAqIG9mKFxuICogICB7IGFnZTogNCwgbmFtZTogJ0hhbnMnfSxcbiAqICAgeyBhZ2U6IDcsIG5hbWU6ICdTb3BoaWUnfSxcbiAqICAgeyBhZ2U6IDUsIG5hbWU6ICdIYW4gU29sbyd9LFxuICogICB7IGFnZTogNSwgbmFtZTogJ0hhblNvcGhpZSd9LFxuICogKS5waXBlKFxuICogICBkaXN0aW5jdFVudGlsU29tZUNoYW5nZWQoWydhZ2UnLCAnbmFtZSddKSxcbiAqIClcbiAqIC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gZGlzcGxheXM6XG4gKiAvLyB7IGFnZTogNCwgbmFtZTogJ0hhbnMnfVxuICogLy8geyBhZ2U6IDcsIG5hbWU6ICdTb3BoaWUnfVxuICogLy8geyBhZ2U6IDUsIG5hbWU6ICdIYW4gU29sbyd9XG4gKiAvLyB7IGFnZTogNSwgbmFtZTogJ0hhblNvcGhpZSd9XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEFuIGV4YW1wbGUgd2l0aCBgS2V5Q29tcGFyZU1hcGBcbiAqIGltcG9ydCB7IG9mIH0gZnJvbSAncnhqcyc7XG4gKiBpbXBvcnQgeyBkaXN0aW5jdFVudGlsU29tZUNoYW5nZWQgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG4gKlxuICogaW50ZXJmYWNlIFBlcnNvbiB7XG4gKiAgICAgYWdlOiBudW1iZXI7XG4gKiAgICAgbmFtZTogc3RyaW5nO1xuICogIH1cbiAqIGNvbnN0IGN1c3RvbUNvbXBhcmlzb246IEtleUNvbXBhcmVNYXA8UGVyc29uPiA9IHtcbiAqICAgbmFtZTogKG9sZE5hbWUsIG5ld05hbWUpID0+IG9sZE5hbWUuc3Vic3RyaW5nKDAsIDIpID09PSBuZXdOYW1lLnN1YnN0cmluZygwLCAyKVxuICogfTtcbiAqXG4gKiBvZihcbiAqICAgICB7IGFnZTogNCwgbmFtZTogJ0hhbnMnfSxcbiAqICAgICB7IGFnZTogNywgbmFtZTogJ1NvcGhpZSd9LFxuICogICAgIHsgYWdlOiA1LCBuYW1lOiAnSGFuIFNvbG8nfSxcbiAqICAgICB7IGFnZTogNSwgbmFtZTogJ0hhblNvcGhpZSd9LFxuICogICApLnBpcGUoXG4gKiAgICAgZGlzdGluY3RVbnRpbFNvbWVDaGFuZ2VkKFsnYWdlJywgJ25hbWUnXSwgY3VzdG9tQ29tcGFyaXNvbiksXG4gKiAgIClcbiAqICAgLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBkaXNwbGF5czpcbiAqIC8vIHsgYWdlOiA0LCBuYW1lOiAnSGFucycgfVxuICogLy8geyBhZ2U6IDcsIG5hbWU6ICdTb3BoaWUnIH1cbiAqIC8vIHsgYWdlOiA1LCBuYW1lOiAnSGFuIFNvbG8nIH1cbiAqXG4gKiBAcGFyYW0ge0tbXX0ga2V5cyBTdHJpbmcga2V5IGZvciBvYmplY3QgcHJvcGVydHkgbG9va3VwIG9uIGVhY2ggaXRlbS5cbiAqIEBwYXJhbSB7S2V5Q29tcGFyZU1hcDxUPn0gW2tleUNvbXBhcmVNYXBdIE9wdGlvbmFsIEtleUNvbXBhcmVNYXAgdG8gZXhwbGljaXRseSBkZWZpbmUgY29tcGFyaXNvbnMgZm9yIHNvbWUgb2YgdGhlIGtleXNcbiAqIEBkb2NzUGFnZSBkaXN0aW5jdFVudGlsU29tZUNoYW5nZWRcbiAqIEBkb2NzQ2F0ZWdvcnkgb3BlcmF0b3JzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXN0aW5jdFVudGlsU29tZUNoYW5nZWQ8VCBleHRlbmRzIG9iamVjdCwgSyBleHRlbmRzIGtleW9mIFQ+KFxuICBrZXlzOiBLW10sXG4gIGtleUNvbXBhcmVNYXA/OiBLZXlDb21wYXJlTWFwPFQ+XG4pOiBNb25vVHlwZU9wZXJhdG9yRnVuY3Rpb248VD4ge1xuICAvLyBkZWZhdWx0IGNvbXBhcmUgZnVuY3Rpb24gYXBwbHlpbmcgPT09IHRvIGV2ZXJ5IGtleVxuICBsZXQgZGlzdGluY3RDb21wYXJlOiBDb21wYXJlRm48VD4gPSAob2xkU3RhdGUsIG5ld1N0YXRlKSA9PlxuICAgIGtleXMuc29tZShcbiAgICAgIChrZXkpID0+XG4gICAgICAgICFkZWZhdWx0Q29tcGFyZShzYWZlUGx1Y2sob2xkU3RhdGUsIFtrZXldKSwgc2FmZVBsdWNrKG5ld1N0YXRlLCBba2V5XSkpXG4gICAgKTtcblxuICAvLyBnZW5lcmF0ZSBjb21wYXJlIGZ1bmN0aW9uIHJlc3BlY3RpbmcgZXZlcnkgY2FzZSBvZiBwcm92aWRlZCBrZXlDb21wYXJlTWFwXG4gIGlmIChrZXlDb21wYXJlTWFwICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBjb21wYXJlID0gKGtleTogSykgPT4ge1xuICAgICAgcmV0dXJuIGtleUNvbXBhcmVNYXAuaGFzT3duUHJvcGVydHkoa2V5KSAmJlxuICAgICAgICBrZXlDb21wYXJlTWFwW2tleV0gIT09IHVuZGVmaW5lZFxuICAgICAgICA/IChrZXlDb21wYXJlTWFwW2tleV0gYXMgQ29tcGFyZUZuPFRbS10+KVxuICAgICAgICA6IGRlZmF1bHRDb21wYXJlO1xuICAgIH07XG4gICAgZGlzdGluY3RDb21wYXJlID0gKG9sZFN0YXRlLCBuZXdTdGF0ZSkgPT4ge1xuICAgICAgcmV0dXJuIGtleXMuc29tZShcbiAgICAgICAgKGtleSkgPT5cbiAgICAgICAgICAhY29tcGFyZShrZXkpKHNhZmVQbHVjayhvbGRTdGF0ZSwgW2tleV0pLCBzYWZlUGx1Y2sobmV3U3RhdGUsIFtrZXldKSlcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZGlzdGluY3RVbnRpbENoYW5nZWQoKG9sZFYsIG5ld1YpID0+ICFkaXN0aW5jdENvbXBhcmUob2xkViwgbmV3VikpO1xufVxuIl19