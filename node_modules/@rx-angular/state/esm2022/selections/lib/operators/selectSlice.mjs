import { filter, map } from 'rxjs/operators';
import { distinctUntilSomeChanged } from './distinctUntilSomeChanged';
/**
 * @description
 *
 * Returns an Observable that emits only the provided `keys` emitted by the source Observable. Each key will get
 * filtered to only emit _defined_ values as well as checked for distinct emissions.
 * Comparison will be done for each set key in the `keys` array.
 *
 * `selectSlice` will only emit _valid_ selections. A selection is _valid_ if every
 * selected key exists and is defined in the source Observable. This ensures that the `selectSlice`
 * operator will always return a complete slice with all values defined.
 *
 * You can fine grain your distinct checks by providing a `KeyCompareMap` with those keys you want to compute
 * explicitly different
 *
 * @example
 *
 * // An example with a custom comparison applied to each key
 * import { of } from 'rxjs';
 * import { selectSlice } from 'rx-angular/state';
 *
 *
 * const state$: Observable<MyState> = of(
 *  { title: 'myTitle', panelOpen: true},
 *  { title: 'myTitle2', panelOpen: true},
 *  { title: 'newTitle', panelOpen: true},
 *  { title: 'newTitle', panelOpen: false}
 * )
 * .pipe(
 *     selectSlice(['title', 'panelOpen']),
 *   )
 *   .subscribe(x => console.log(x));
 *
 * // displays:
 * //  { title: 'myTitle', panelOpen: true },
 * //  { title: 'myTitle2', panelOpen: true },
 * //  { title: 'newTitle', panelOpen: true },
 * //  { title: 'newTitle', panelOpen: false }
 *
 * @example
 *
 * import { of, Observable } from 'rxjs';
 * import { tap } from 'rxjs/operators';
 * import { selectSlice } from 'rx-angular/state';
 *
 * interface MyState {
 *    title: string;
 *    items: string[];
 *    panelOpen: boolean;
 * }
 * // Select items and title.
 * // apply custom compare logic for the items array
 * const customComparison: KeyCompareMap<MyState> = {
 *   items: (oldItems, newItems) => compareItems(oldItems, newItems)
 * };
 * const state$: Observable<MyState> = of(
 * { title: 'myTitle', items: ['foo', 'bar'], panelOpen: true },
 * { title: 'myTitle', items: ['foo', 'bar'], panelOpen: false },
 * { title: 'nextTitle', items: ['foo', 'baR'], panelOpen: true },
 * { title: 'nextTitle', items: ['fooRz', 'boo'], panelOpen: false },
 * );
 * const slice$ = state$.pipe(selectSlice(['title', 'items'], customComparison), tap(console.log)).subscribe();
 *
 * // displays:
 * // { title: 'myTitle', items: ['foo', 'bar'] }
 * // { title: 'nextTitle', items: ['foo', 'baR'] }
 * // { title: 'nextTitle', items: ['fooRz', 'boo'] }
 *
 * @param {(K)[]} keys - the array of keys which should be selected
 * @param {KeyCompareMap<{ [P in K]: T[P] }>} [keyCompareMap] Optional KeyCompareMap to provide custom compare logic
 * for some the keys
 * @docsPage selectSlice
 * @docsCategory operators
 */
export function selectSlice(keys, keyCompareMap) {
    return (o$) => o$.pipe(filter((state) => state !== undefined), map((state) => {
        // forward null
        if (state === null) {
            return null;
        }
        // an array of all keys which exist and are _defined_ in the state object
        const definedKeys = keys
            // filter out undefined properties e. g. {}, { str: undefined }
            .filter((k) => state.hasOwnProperty(k) && state[k] !== undefined);
        // we want to ensure to only emit _valid_ selections
        // a selection is _valid_ if every selected key exists and has a value:
        // {} => selectSlice(['foo']) => no emission
        // {str: 'test'} => selectSlice([]) => no emission
        // {str: 'test'} => selectSlice(['notPresent']) => no emission
        // {str: 'test'} => state.select(selectSlice([])) => no emission
        // {str: 'test'} => state.select(selectSlice(['notPresent'])) => no emission
        // {str: undefined} => state.select(selectSlice(['str'])) => no emission
        // {str: 'test', foo: undefined } => state.select(selectSlice(['foo'])) => no emission
        if (definedKeys.length < keys.length) {
            return undefined;
        }
        // create the selected slice
        return definedKeys.reduce((vm, key) => {
            vm[key] = state[key];
            return vm;
        }, {});
    }), filter((v) => v !== undefined), distinctUntilSomeChanged(keys, keyCompareMap));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VsZWN0U2xpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9saWJzL3N0YXRlL3NlbGVjdGlvbnMvc3JjL2xpYi9vcGVyYXRvcnMvc2VsZWN0U2xpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUU3QyxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUV0RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBd0VHO0FBQ0gsTUFBTSxVQUFVLFdBQVcsQ0FDekIsSUFBUyxFQUNULGFBQWlEO0lBRWpELE9BQU8sQ0FBQyxFQUFpQixFQUErQixFQUFFLENBQ3hELEVBQUUsQ0FBQyxJQUFJLENBQ0wsTUFBTSxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxLQUFLLEtBQUssU0FBUyxDQUFDLEVBQ3RDLEdBQUcsQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFO1FBQ1osZUFBZTtRQUNmLElBQUksS0FBSyxLQUFLLElBQUksRUFBRSxDQUFDO1lBQ25CLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUNELHlFQUF5RTtRQUN6RSxNQUFNLFdBQVcsR0FBRyxJQUFJO1lBQ3RCLCtEQUErRDthQUM5RCxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEtBQUssQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLFNBQVMsQ0FBQyxDQUFDO1FBRXBFLG9EQUFvRDtRQUNwRCx1RUFBdUU7UUFFdkUsNENBQTRDO1FBQzVDLGtEQUFrRDtRQUNsRCw4REFBOEQ7UUFDOUQsZ0VBQWdFO1FBQ2hFLDRFQUE0RTtRQUM1RSx3RUFBd0U7UUFDeEUsc0ZBQXNGO1FBQ3RGLElBQUksV0FBVyxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7WUFDckMsT0FBTyxTQUFTLENBQUM7UUFDbkIsQ0FBQztRQUVELDRCQUE0QjtRQUM1QixPQUFPLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLEVBQUUsR0FBRyxFQUFFLEVBQUU7WUFDcEMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNyQixPQUFPLEVBQUUsQ0FBQztRQUNaLENBQUMsRUFBRSxFQUFxQixDQUFDLENBQUM7SUFDNUIsQ0FBQyxDQUFDLEVBQ0YsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEtBQUssU0FBUyxDQUFDLEVBQzlCLHdCQUF3QixDQUFDLElBQUksRUFBRSxhQUFhLENBQUMsQ0FDOUMsQ0FBQztBQUNOLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPYnNlcnZhYmxlLCBPcGVyYXRvckZ1bmN0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBmaWx0ZXIsIG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IEtleUNvbXBhcmVNYXAsIFBpY2tTbGljZSB9IGZyb20gJy4uL2ludGVyZmFjZXMvaW5kZXgnO1xuaW1wb3J0IHsgZGlzdGluY3RVbnRpbFNvbWVDaGFuZ2VkIH0gZnJvbSAnLi9kaXN0aW5jdFVudGlsU29tZUNoYW5nZWQnO1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIG9ubHkgdGhlIHByb3ZpZGVkIGBrZXlzYCBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS4gRWFjaCBrZXkgd2lsbCBnZXRcbiAqIGZpbHRlcmVkIHRvIG9ubHkgZW1pdCBfZGVmaW5lZF8gdmFsdWVzIGFzIHdlbGwgYXMgY2hlY2tlZCBmb3IgZGlzdGluY3QgZW1pc3Npb25zLlxuICogQ29tcGFyaXNvbiB3aWxsIGJlIGRvbmUgZm9yIGVhY2ggc2V0IGtleSBpbiB0aGUgYGtleXNgIGFycmF5LlxuICpcbiAqIGBzZWxlY3RTbGljZWAgd2lsbCBvbmx5IGVtaXQgX3ZhbGlkXyBzZWxlY3Rpb25zLiBBIHNlbGVjdGlvbiBpcyBfdmFsaWRfIGlmIGV2ZXJ5XG4gKiBzZWxlY3RlZCBrZXkgZXhpc3RzIGFuZCBpcyBkZWZpbmVkIGluIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS4gVGhpcyBlbnN1cmVzIHRoYXQgdGhlIGBzZWxlY3RTbGljZWBcbiAqIG9wZXJhdG9yIHdpbGwgYWx3YXlzIHJldHVybiBhIGNvbXBsZXRlIHNsaWNlIHdpdGggYWxsIHZhbHVlcyBkZWZpbmVkLlxuICpcbiAqIFlvdSBjYW4gZmluZSBncmFpbiB5b3VyIGRpc3RpbmN0IGNoZWNrcyBieSBwcm92aWRpbmcgYSBgS2V5Q29tcGFyZU1hcGAgd2l0aCB0aG9zZSBrZXlzIHlvdSB3YW50IHRvIGNvbXB1dGVcbiAqIGV4cGxpY2l0bHkgZGlmZmVyZW50XG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBbiBleGFtcGxlIHdpdGggYSBjdXN0b20gY29tcGFyaXNvbiBhcHBsaWVkIHRvIGVhY2gga2V5XG4gKiBpbXBvcnQgeyBvZiB9IGZyb20gJ3J4anMnO1xuICogaW1wb3J0IHsgc2VsZWN0U2xpY2UgfSBmcm9tICdyeC1hbmd1bGFyL3N0YXRlJztcbiAqXG4gKlxuICogY29uc3Qgc3RhdGUkOiBPYnNlcnZhYmxlPE15U3RhdGU+ID0gb2YoXG4gKiAgeyB0aXRsZTogJ215VGl0bGUnLCBwYW5lbE9wZW46IHRydWV9LFxuICogIHsgdGl0bGU6ICdteVRpdGxlMicsIHBhbmVsT3BlbjogdHJ1ZX0sXG4gKiAgeyB0aXRsZTogJ25ld1RpdGxlJywgcGFuZWxPcGVuOiB0cnVlfSxcbiAqICB7IHRpdGxlOiAnbmV3VGl0bGUnLCBwYW5lbE9wZW46IGZhbHNlfVxuICogKVxuICogLnBpcGUoXG4gKiAgICAgc2VsZWN0U2xpY2UoWyd0aXRsZScsICdwYW5lbE9wZW4nXSksXG4gKiAgIClcbiAqICAgLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBkaXNwbGF5czpcbiAqIC8vICB7IHRpdGxlOiAnbXlUaXRsZScsIHBhbmVsT3BlbjogdHJ1ZSB9LFxuICogLy8gIHsgdGl0bGU6ICdteVRpdGxlMicsIHBhbmVsT3BlbjogdHJ1ZSB9LFxuICogLy8gIHsgdGl0bGU6ICduZXdUaXRsZScsIHBhbmVsT3BlbjogdHJ1ZSB9LFxuICogLy8gIHsgdGl0bGU6ICduZXdUaXRsZScsIHBhbmVsT3BlbjogZmFsc2UgfVxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogaW1wb3J0IHsgb2YsIE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbiAqIGltcG9ydCB7IHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbiAqIGltcG9ydCB7IHNlbGVjdFNsaWNlIH0gZnJvbSAncngtYW5ndWxhci9zdGF0ZSc7XG4gKlxuICogaW50ZXJmYWNlIE15U3RhdGUge1xuICogICAgdGl0bGU6IHN0cmluZztcbiAqICAgIGl0ZW1zOiBzdHJpbmdbXTtcbiAqICAgIHBhbmVsT3BlbjogYm9vbGVhbjtcbiAqIH1cbiAqIC8vIFNlbGVjdCBpdGVtcyBhbmQgdGl0bGUuXG4gKiAvLyBhcHBseSBjdXN0b20gY29tcGFyZSBsb2dpYyBmb3IgdGhlIGl0ZW1zIGFycmF5XG4gKiBjb25zdCBjdXN0b21Db21wYXJpc29uOiBLZXlDb21wYXJlTWFwPE15U3RhdGU+ID0ge1xuICogICBpdGVtczogKG9sZEl0ZW1zLCBuZXdJdGVtcykgPT4gY29tcGFyZUl0ZW1zKG9sZEl0ZW1zLCBuZXdJdGVtcylcbiAqIH07XG4gKiBjb25zdCBzdGF0ZSQ6IE9ic2VydmFibGU8TXlTdGF0ZT4gPSBvZihcbiAqIHsgdGl0bGU6ICdteVRpdGxlJywgaXRlbXM6IFsnZm9vJywgJ2JhciddLCBwYW5lbE9wZW46IHRydWUgfSxcbiAqIHsgdGl0bGU6ICdteVRpdGxlJywgaXRlbXM6IFsnZm9vJywgJ2JhciddLCBwYW5lbE9wZW46IGZhbHNlIH0sXG4gKiB7IHRpdGxlOiAnbmV4dFRpdGxlJywgaXRlbXM6IFsnZm9vJywgJ2JhUiddLCBwYW5lbE9wZW46IHRydWUgfSxcbiAqIHsgdGl0bGU6ICduZXh0VGl0bGUnLCBpdGVtczogWydmb29SeicsICdib28nXSwgcGFuZWxPcGVuOiBmYWxzZSB9LFxuICogKTtcbiAqIGNvbnN0IHNsaWNlJCA9IHN0YXRlJC5waXBlKHNlbGVjdFNsaWNlKFsndGl0bGUnLCAnaXRlbXMnXSwgY3VzdG9tQ29tcGFyaXNvbiksIHRhcChjb25zb2xlLmxvZykpLnN1YnNjcmliZSgpO1xuICpcbiAqIC8vIGRpc3BsYXlzOlxuICogLy8geyB0aXRsZTogJ215VGl0bGUnLCBpdGVtczogWydmb28nLCAnYmFyJ10gfVxuICogLy8geyB0aXRsZTogJ25leHRUaXRsZScsIGl0ZW1zOiBbJ2ZvbycsICdiYVInXSB9XG4gKiAvLyB7IHRpdGxlOiAnbmV4dFRpdGxlJywgaXRlbXM6IFsnZm9vUnonLCAnYm9vJ10gfVxuICpcbiAqIEBwYXJhbSB7KEspW119IGtleXMgLSB0aGUgYXJyYXkgb2Yga2V5cyB3aGljaCBzaG91bGQgYmUgc2VsZWN0ZWRcbiAqIEBwYXJhbSB7S2V5Q29tcGFyZU1hcDx7IFtQIGluIEtdOiBUW1BdIH0+fSBba2V5Q29tcGFyZU1hcF0gT3B0aW9uYWwgS2V5Q29tcGFyZU1hcCB0byBwcm92aWRlIGN1c3RvbSBjb21wYXJlIGxvZ2ljXG4gKiBmb3Igc29tZSB0aGUga2V5c1xuICogQGRvY3NQYWdlIHNlbGVjdFNsaWNlXG4gKiBAZG9jc0NhdGVnb3J5IG9wZXJhdG9yc1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2VsZWN0U2xpY2U8VCBleHRlbmRzIG9iamVjdCwgSyBleHRlbmRzIGtleW9mIFQ+KFxuICBrZXlzOiBLW10sXG4gIGtleUNvbXBhcmVNYXA/OiBLZXlDb21wYXJlTWFwPHsgW1AgaW4gS106IFRbUF0gfT5cbik6IE9wZXJhdG9yRnVuY3Rpb248VCwgUGlja1NsaWNlPFQsIEs+PiB7XG4gIHJldHVybiAobyQ6IE9ic2VydmFibGU8VD4pOiBPYnNlcnZhYmxlPFBpY2tTbGljZTxULCBLPj4gPT5cbiAgICBvJC5waXBlKFxuICAgICAgZmlsdGVyKChzdGF0ZSkgPT4gc3RhdGUgIT09IHVuZGVmaW5lZCksXG4gICAgICBtYXAoKHN0YXRlKSA9PiB7XG4gICAgICAgIC8vIGZvcndhcmQgbnVsbFxuICAgICAgICBpZiAoc3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBhbiBhcnJheSBvZiBhbGwga2V5cyB3aGljaCBleGlzdCBhbmQgYXJlIF9kZWZpbmVkXyBpbiB0aGUgc3RhdGUgb2JqZWN0XG4gICAgICAgIGNvbnN0IGRlZmluZWRLZXlzID0ga2V5c1xuICAgICAgICAgIC8vIGZpbHRlciBvdXQgdW5kZWZpbmVkIHByb3BlcnRpZXMgZS4gZy4ge30sIHsgc3RyOiB1bmRlZmluZWQgfVxuICAgICAgICAgIC5maWx0ZXIoKGspID0+IHN0YXRlLmhhc093blByb3BlcnR5KGspICYmIHN0YXRlW2tdICE9PSB1bmRlZmluZWQpO1xuXG4gICAgICAgIC8vIHdlIHdhbnQgdG8gZW5zdXJlIHRvIG9ubHkgZW1pdCBfdmFsaWRfIHNlbGVjdGlvbnNcbiAgICAgICAgLy8gYSBzZWxlY3Rpb24gaXMgX3ZhbGlkXyBpZiBldmVyeSBzZWxlY3RlZCBrZXkgZXhpc3RzIGFuZCBoYXMgYSB2YWx1ZTpcblxuICAgICAgICAvLyB7fSA9PiBzZWxlY3RTbGljZShbJ2ZvbyddKSA9PiBubyBlbWlzc2lvblxuICAgICAgICAvLyB7c3RyOiAndGVzdCd9ID0+IHNlbGVjdFNsaWNlKFtdKSA9PiBubyBlbWlzc2lvblxuICAgICAgICAvLyB7c3RyOiAndGVzdCd9ID0+IHNlbGVjdFNsaWNlKFsnbm90UHJlc2VudCddKSA9PiBubyBlbWlzc2lvblxuICAgICAgICAvLyB7c3RyOiAndGVzdCd9ID0+IHN0YXRlLnNlbGVjdChzZWxlY3RTbGljZShbXSkpID0+IG5vIGVtaXNzaW9uXG4gICAgICAgIC8vIHtzdHI6ICd0ZXN0J30gPT4gc3RhdGUuc2VsZWN0KHNlbGVjdFNsaWNlKFsnbm90UHJlc2VudCddKSkgPT4gbm8gZW1pc3Npb25cbiAgICAgICAgLy8ge3N0cjogdW5kZWZpbmVkfSA9PiBzdGF0ZS5zZWxlY3Qoc2VsZWN0U2xpY2UoWydzdHInXSkpID0+IG5vIGVtaXNzaW9uXG4gICAgICAgIC8vIHtzdHI6ICd0ZXN0JywgZm9vOiB1bmRlZmluZWQgfSA9PiBzdGF0ZS5zZWxlY3Qoc2VsZWN0U2xpY2UoWydmb28nXSkpID0+IG5vIGVtaXNzaW9uXG4gICAgICAgIGlmIChkZWZpbmVkS2V5cy5sZW5ndGggPCBrZXlzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgdGhlIHNlbGVjdGVkIHNsaWNlXG4gICAgICAgIHJldHVybiBkZWZpbmVkS2V5cy5yZWR1Y2UoKHZtLCBrZXkpID0+IHtcbiAgICAgICAgICB2bVtrZXldID0gc3RhdGVba2V5XTtcbiAgICAgICAgICByZXR1cm4gdm07XG4gICAgICAgIH0sIHt9IGFzIFBpY2tTbGljZTxULCBLPik7XG4gICAgICB9KSxcbiAgICAgIGZpbHRlcigodikgPT4gdiAhPT0gdW5kZWZpbmVkKSxcbiAgICAgIGRpc3RpbmN0VW50aWxTb21lQ2hhbmdlZChrZXlzLCBrZXlDb21wYXJlTWFwKVxuICAgICk7XG59XG4iXX0=