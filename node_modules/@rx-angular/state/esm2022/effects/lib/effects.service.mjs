import { Injectable, Optional } from '@angular/core';
import { EMPTY, from, pipe, Subject, Subscription, } from 'rxjs';
import { catchError, filter, mapTo, mergeAll, share, takeUntil, tap, } from 'rxjs/operators';
import { toHook, untilDestroyed } from './utils';
import * as i0 from "@angular/core";
/**
 * @deprecated - use rxEffects instead
 *
 * Reduces subscription boilerplate for performing observable-based side-effects in components.
 *
 * Before:
 * ```ts
 * @Component({
 *   // ...
 * })
 * export class FooComponent implements OnDestroy {
 *   private readonly destroy$ = new Subject<void>();
 *
 *   constructor() {
 *     obs$.pipe(takeUntil(this.destroy$)).subscribe(doSideEffect);
 *   }
 *
 *   ngOnDestroy(): void {
 *     this.destroy$.next();
 *     this.destroy$.complete();
 *   }
 * }
 * ```
 *
 * After:
 * ```ts
 * @Component({
 *   // ...
 *   providers: [RxEffects],
 * })
 * export class FooComponent {
 *   constructor(effects: RxEffects) {
 *     effects.register(obs$, doSideEffect);
 *     // OR
 *     effects.register(obs$.pipe(tap(doSideEffect)));
 *     // OR
 *     effects.register(obs$.subscribe(doSideEffect));
 *   }
 * }
 * ```
 *
 * NOTE: Avoid calling register/unregister/subscribe inside the side-effect function.
 */
export class RxEffects {
    errorHandler;
    constructor(errorHandler) {
        this.errorHandler = errorHandler;
    }
    static nextId = 0;
    _hooks$ = new Subject();
    observables$ = new Subject();
    // we have to use publish here to make it hot (composition happens without subscriber)
    effects$ = this.observables$.pipe(mergeAll(), share());
    subscription = this.effects$.subscribe();
    onDestroy$ = this._hooks$.pipe(toHook('destroy'));
    destroyers = {};
    register(obsOrSub, fnOrObj) {
        if (obsOrSub instanceof Subscription) {
            this.subscription.add(obsOrSub);
            return;
        }
        const effectId = RxEffects.nextId++;
        const destroy$ = (this.destroyers[effectId] = new Subject());
        const applyBehavior = pipe(mapTo(effectId), takeUntil(destroy$));
        if (fnOrObj != null) {
            this.observables$.next(from(obsOrSub).pipe(
            // ternary expression is to help Typescript infer overloads
            typeof fnOrObj === 'function' ? tap(fnOrObj) : tap(fnOrObj), catchError((err) => {
                this.errorHandler?.handleError(err);
                return EMPTY;
            }), applyBehavior));
        }
        else {
            this.observables$.next(from(obsOrSub).pipe(applyBehavior));
        }
        return effectId;
    }
    /**
     * Imperatively cancel a side-effect while the component is still running.
     *
     * Note that all effects are automatically cancelled when a component is destroyed,
     * so you most often won't need to call this method.
     * @param effectId Effect ID (returned by register method)
     */
    unregister(effectId) {
        this.destroyers[effectId]?.next();
    }
    /**
     * Fires a sideEffect when the instances `OnDestroy` hook is fired.
     *
     * @example
     * effects.registerOnDestroy(mode => localStorage.setItem('colorMode', mode));
     *
     * @param sideEffect
     */
    registerOnDestroy(sideEffect) {
        return this.register(this.onDestroy$, sideEffect);
    }
    /**
     * Operator that unsubscribes based on emission of an registered effect.
     *
     * @NOTICE
     * This operator has to be placed always at the end of the operator chain (before the subscription).
     * Otherwise we may leak as a subsequent operator could instantiate new ongoing Observables which will not get unsubscribed.
     *
     * @example
     * const effectId1 = effects.register(
     *   colorMode$.subscribe(mode => localStorage.setItem('colorMode', mode))
     * );
     *
     * someValue$.pipe(
     *    effect.untilEffect(effectId1)
     * )
     *
     */
    untilEffect(effectId) {
        return (source) => source.pipe(untilDestroyed(this), takeUntil(this.effects$.pipe(filter((eId) => eId === effectId))));
    }
    /**
     * @internal
     */
    ngOnDestroy() {
        this._hooks$.next({ destroy: true });
        this.subscription.unsubscribe();
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: RxEffects, deps: [{ token: i0.ErrorHandler, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: RxEffects });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: RxEffects, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: i0.ErrorHandler, decorators: [{
                    type: Optional
                }] }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWZmZWN0cy5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vbGlicy9zdGF0ZS9lZmZlY3RzL3NyYy9saWIvZWZmZWN0cy5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBZ0IsVUFBVSxFQUFhLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUM5RSxPQUFPLEVBQ0wsS0FBSyxFQUNMLElBQUksRUFJSixJQUFJLEVBQ0osT0FBTyxFQUNQLFlBQVksR0FDYixNQUFNLE1BQU0sQ0FBQztBQUNkLE9BQU8sRUFDTCxVQUFVLEVBQ1YsTUFBTSxFQUNOLEtBQUssRUFDTCxRQUFRLEVBQ1IsS0FBSyxFQUNMLFNBQVMsRUFDVCxHQUFHLEdBQ0osTUFBTSxnQkFBZ0IsQ0FBQztBQUV4QixPQUFPLEVBQUUsTUFBTSxFQUFFLGNBQWMsRUFBRSxNQUFNLFNBQVMsQ0FBQzs7QUFFakQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTBDRztBQUVILE1BQU0sT0FBTyxTQUFTO0lBR0Q7SUFGbkIsWUFFbUIsWUFBaUM7UUFBakMsaUJBQVksR0FBWixZQUFZLENBQXFCO0lBQ2pELENBQUM7SUFFSSxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztJQUNqQixPQUFPLEdBQUcsSUFBSSxPQUFPLEVBQWUsQ0FBQztJQUM3QixZQUFZLEdBQUcsSUFBSSxPQUFPLEVBQXVCLENBQUM7SUFDbkUsc0ZBQXNGO0lBQ3JFLFFBQVEsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDO0lBQ3ZELFlBQVksR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsRUFBRSxDQUFDO0lBQzFELFVBQVUsR0FBd0IsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7SUFDdEQsVUFBVSxHQUFrQyxFQUFFLENBQUM7SUF3RWhFLFFBQVEsQ0FDTixRQUEyQyxFQUMzQyxPQUFtRDtRQUVuRCxJQUFJLFFBQVEsWUFBWSxZQUFZLEVBQUUsQ0FBQztZQUNyQyxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUNoQyxPQUFPO1FBQ1QsQ0FBQztRQUNELE1BQU0sUUFBUSxHQUFHLFNBQVMsQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUNwQyxNQUFNLFFBQVEsR0FBRyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLEdBQUcsSUFBSSxPQUFPLEVBQVEsQ0FBQyxDQUFDO1FBQ25FLE1BQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLEVBQUUsU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7UUFDakUsSUFBSSxPQUFPLElBQUksSUFBSSxFQUFFLENBQUM7WUFDcEIsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQ3BCLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJO1lBQ2pCLDJEQUEyRDtZQUMzRCxPQUFPLE9BQU8sS0FBSyxVQUFVLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxFQUMzRCxVQUFVLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRTtnQkFDakIsSUFBSSxDQUFDLFlBQVksRUFBRSxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQ3BDLE9BQU8sS0FBSyxDQUFDO1lBQ2YsQ0FBQyxDQUFDLEVBQ0YsYUFBYSxDQUNkLENBQ0YsQ0FBQztRQUNKLENBQUM7YUFBTSxDQUFDO1lBQ04sSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDO1FBQzdELENBQUM7UUFDRCxPQUFPLFFBQVEsQ0FBQztJQUNsQixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsVUFBVSxDQUFDLFFBQWdCO1FBQ3pCLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLEVBQUUsSUFBSSxFQUFFLENBQUM7SUFDcEMsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSCxpQkFBaUIsQ0FBQyxVQUFvQztRQUNwRCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxVQUFVLENBQUMsQ0FBQztJQUNwRCxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7T0FnQkc7SUFDSCxXQUFXLENBQUMsUUFBZ0I7UUFDMUIsT0FBTyxDQUFJLE1BQXFCLEVBQUUsRUFBRSxDQUNsQyxNQUFNLENBQUMsSUFBSSxDQUNULGNBQWMsQ0FBQyxJQUFJLENBQUMsRUFDcEIsU0FBUyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsR0FBRyxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FDakUsQ0FBQztJQUNOLENBQUM7SUFFRDs7T0FFRztJQUNILFdBQVc7UUFDVCxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO1FBQ3JDLElBQUksQ0FBQyxZQUFZLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDbEMsQ0FBQzswSEF4S1UsU0FBUzs4SEFBVCxTQUFTOzsyRkFBVCxTQUFTO2tCQURyQixVQUFVOzswQkFHTixRQUFRIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXJyb3JIYW5kbGVyLCBJbmplY3RhYmxlLCBPbkRlc3Ryb3ksIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICBFTVBUWSxcbiAgZnJvbSxcbiAgT2JzZXJ2YWJsZSxcbiAgT2JzZXJ2YWJsZUlucHV0LFxuICBQYXJ0aWFsT2JzZXJ2ZXIsXG4gIHBpcGUsXG4gIFN1YmplY3QsXG4gIFN1YnNjcmlwdGlvbixcbn0gZnJvbSAncnhqcyc7XG5pbXBvcnQge1xuICBjYXRjaEVycm9yLFxuICBmaWx0ZXIsXG4gIG1hcFRvLFxuICBtZXJnZUFsbCxcbiAgc2hhcmUsXG4gIHRha2VVbnRpbCxcbiAgdGFwLFxufSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBEZXN0cm95UHJvcCwgT25EZXN0cm95JCB9IGZyb20gJy4vbW9kZWwnO1xuaW1wb3J0IHsgdG9Ib29rLCB1bnRpbERlc3Ryb3llZCB9IGZyb20gJy4vdXRpbHMnO1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIC0gdXNlIHJ4RWZmZWN0cyBpbnN0ZWFkXG4gKlxuICogUmVkdWNlcyBzdWJzY3JpcHRpb24gYm9pbGVycGxhdGUgZm9yIHBlcmZvcm1pbmcgb2JzZXJ2YWJsZS1iYXNlZCBzaWRlLWVmZmVjdHMgaW4gY29tcG9uZW50cy5cbiAqXG4gKiBCZWZvcmU6XG4gKiBgYGB0c1xuICogQENvbXBvbmVudCh7XG4gKiAgIC8vIC4uLlxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBGb29Db21wb25lbnQgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICogICBwcml2YXRlIHJlYWRvbmx5IGRlc3Ryb3kkID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcbiAqXG4gKiAgIGNvbnN0cnVjdG9yKCkge1xuICogICAgIG9icyQucGlwZSh0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpLnN1YnNjcmliZShkb1NpZGVFZmZlY3QpO1xuICogICB9XG4gKlxuICogICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAqICAgICB0aGlzLmRlc3Ryb3kkLm5leHQoKTtcbiAqICAgICB0aGlzLmRlc3Ryb3kkLmNvbXBsZXRlKCk7XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIEFmdGVyOlxuICogYGBgdHNcbiAqIEBDb21wb25lbnQoe1xuICogICAvLyAuLi5cbiAqICAgcHJvdmlkZXJzOiBbUnhFZmZlY3RzXSxcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgRm9vQ29tcG9uZW50IHtcbiAqICAgY29uc3RydWN0b3IoZWZmZWN0czogUnhFZmZlY3RzKSB7XG4gKiAgICAgZWZmZWN0cy5yZWdpc3RlcihvYnMkLCBkb1NpZGVFZmZlY3QpO1xuICogICAgIC8vIE9SXG4gKiAgICAgZWZmZWN0cy5yZWdpc3RlcihvYnMkLnBpcGUodGFwKGRvU2lkZUVmZmVjdCkpKTtcbiAqICAgICAvLyBPUlxuICogICAgIGVmZmVjdHMucmVnaXN0ZXIob2JzJC5zdWJzY3JpYmUoZG9TaWRlRWZmZWN0KSk7XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIE5PVEU6IEF2b2lkIGNhbGxpbmcgcmVnaXN0ZXIvdW5yZWdpc3Rlci9zdWJzY3JpYmUgaW5zaWRlIHRoZSBzaWRlLWVmZmVjdCBmdW5jdGlvbi5cbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFJ4RWZmZWN0cyBpbXBsZW1lbnRzIE9uRGVzdHJveSwgT25EZXN0cm95JCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIEBPcHRpb25hbCgpXG4gICAgcHJpdmF0ZSByZWFkb25seSBlcnJvckhhbmRsZXI6IEVycm9ySGFuZGxlciB8IG51bGxcbiAgKSB7fVxuXG4gIHByaXZhdGUgc3RhdGljIG5leHRJZCA9IDA7XG4gIHJlYWRvbmx5IF9ob29rcyQgPSBuZXcgU3ViamVjdDxEZXN0cm95UHJvcD4oKTtcbiAgcHJpdmF0ZSByZWFkb25seSBvYnNlcnZhYmxlcyQgPSBuZXcgU3ViamVjdDxPYnNlcnZhYmxlPHVua25vd24+PigpO1xuICAvLyB3ZSBoYXZlIHRvIHVzZSBwdWJsaXNoIGhlcmUgdG8gbWFrZSBpdCBob3QgKGNvbXBvc2l0aW9uIGhhcHBlbnMgd2l0aG91dCBzdWJzY3JpYmVyKVxuICBwcml2YXRlIHJlYWRvbmx5IGVmZmVjdHMkID0gdGhpcy5vYnNlcnZhYmxlcyQucGlwZShtZXJnZUFsbCgpLCBzaGFyZSgpKTtcbiAgcHJpdmF0ZSByZWFkb25seSBzdWJzY3JpcHRpb24gPSB0aGlzLmVmZmVjdHMkLnN1YnNjcmliZSgpO1xuICBvbkRlc3Ryb3kkOiBPYnNlcnZhYmxlPGJvb2xlYW4+ID0gdGhpcy5faG9va3MkLnBpcGUodG9Ib29rKCdkZXN0cm95JykpO1xuICBwcml2YXRlIHJlYWRvbmx5IGRlc3Ryb3llcnM6IFJlY29yZDxudW1iZXIsIFN1YmplY3Q8dm9pZD4+ID0ge307XG5cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGEgc2lkZS1lZmZlY3Qgd2hlbmV2ZXIgYSBzb3VyY2Ugb2JzZXJ2YWJsZSBlbWl0cywgYW5kIGhhbmRsZXMgaXRzIHN1YnNjcmlwdGlvbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWZmZWN0cy5yZWdpc3RlcihcbiAgICogICBjb2xvck1vZGUkLFxuICAgKiAgIG1vZGUgPT4gbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2NvbG9yTW9kZScsIG1vZGUpXG4gICAqICk7XG4gICAqXG4gICAqIEBwYXJhbSBzb3VyY2VPYnMgU291cmNlIG9ic2VydmFibGUgaW5wdXRcbiAgICogQHBhcmFtIHNpZGVFZmZlY3RGbiBGdW5jdGlvbiB3aXRoIHNpZGUtZWZmZWN0XG4gICAqIEByZXR1cm5zIEVmZmVjdCBJRCAoY2FuIGJlIHVzZWQgdG8gdW5yZWdpc3RlciBpbXBlcmF0aXZlbHkpXG4gICAqL1xuICByZWdpc3RlcjxUPihcbiAgICBzb3VyY2VPYnM6IE9ic2VydmFibGVJbnB1dDxUPixcbiAgICBzaWRlRWZmZWN0Rm46ICh2YWx1ZTogVCkgPT4gdm9pZFxuICApOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFN1YnNjcmliZSB0byBzb3VyY2Ugb2JzZXJ2YWJsZSB1c2luZyBhbiBvYnNlcnZlciBvYmplY3QuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVmZmVjdHMucmVnaXN0ZXIoXG4gICAqICAgY29sb3JNb2RlJCxcbiAgICogICB7XG4gICAqICAgICBuZXh0OiBtb2RlID0+IGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdjb2xvck1vZGUnLCBtb2RlKSxcbiAgICogICAgIGVycm9yOiBlcnIgPT4ge1xuICAgKiAgICAgICBjb25zb2xlLmVycm9yKCdDb2xvciBtb2RlIGVycm9yOiAnLCBlcnIpO1xuICAgKiAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnY29sb3JNb2RlJyk7XG4gICAqICAgICB9XG4gICAqICAgfVxuICAgKiApO1xuICAgKlxuICAgKiBAcGFyYW0gc291cmNlT2JzIFNvdXJjZSBvYnNlcnZhYmxlIGlucHV0XG4gICAqIEBwYXJhbSBvYnNlcnZlciBPYnNlcnZlciBvYmplY3RcbiAgICovXG4gIHJlZ2lzdGVyPFQ+KFxuICAgIHNvdXJjZU9iczogT2JzZXJ2YWJsZUlucHV0PFQ+LFxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogdW5pZmllZC1zaWduYXR1cmVzXG4gICAgb2JzZXJ2ZXI6IFBhcnRpYWxPYnNlcnZlcjxUPlxuICApOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgc3Vic2NyaXB0aW9uIGZvciBhbiBvYnNlcnZhYmxlIHdpdGggYSBzaWRlLWVmZmVjdC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWZmZWN0cy5yZWdpc3RlcihcbiAgICogICBjb2xvck1vZGUkLnBpcGUoXG4gICAqICAgICB0YXAobW9kZSA9PiBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnY29sb3JNb2RlJywgbW9kZSkpXG4gICAqICAgKVxuICAgKiApO1xuICAgKlxuICAgKiBAcGFyYW0gc2lkZUVmZmVjdE9icyBPYnNlcnZhYmxlIGlucHV0IHdpdGggc2lkZS1lZmZlY3RcbiAgICogQHJldHVybnMgRWZmZWN0IElEIChjYW4gYmUgdXNlZCB0byB1bnJlZ2lzdGVyIGltcGVyYXRpdmVseSlcbiAgICovXG4gIHJlZ2lzdGVyKHNpZGVFZmZlY3RPYnM6IE9ic2VydmFibGVJbnB1dDx1bmtub3duPik6IG51bWJlcjtcblxuICAvKipcbiAgICogSGFuZGxlcyBzdWJzY3JpcHRpb24gdG8gYW4gb2JzZXJ2YWJsZSB3aXRoIGEgc2lkZS1lZmZlY3QuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGVmZmVjdHMucmVnaXN0ZXIoXG4gICAqICAgY29sb3JNb2RlJC5zdWJzY3JpYmUobW9kZSA9PiBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnY29sb3JNb2RlJywgbW9kZSkpXG4gICAqICk7XG4gICAqXG4gICAqIEBwYXJhbSBzdWJzY3JpcHRpb24gU3Vic2NyaXB0aW9uIHRvIG9ic2VydmFibGUgd2l0aCBzaWRlLWVmZmVjdFxuICAgKi9cbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiB1bmlmaWVkLXNpZ25hdHVyZXNcbiAgcmVnaXN0ZXIoc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb24pOiB2b2lkO1xuXG4gIHJlZ2lzdGVyPFQ+KFxuICAgIG9ic09yU3ViOiBPYnNlcnZhYmxlSW5wdXQ8VD4gfCBTdWJzY3JpcHRpb24sXG4gICAgZm5Pck9iaj86ICgodmFsdWU6IFQpID0+IHZvaWQpIHwgUGFydGlhbE9ic2VydmVyPFQ+XG4gICk6IG51bWJlciB8IHZvaWQge1xuICAgIGlmIChvYnNPclN1YiBpbnN0YW5jZW9mIFN1YnNjcmlwdGlvbikge1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb24uYWRkKG9ic09yU3ViKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZWZmZWN0SWQgPSBSeEVmZmVjdHMubmV4dElkKys7XG4gICAgY29uc3QgZGVzdHJveSQgPSAodGhpcy5kZXN0cm95ZXJzW2VmZmVjdElkXSA9IG5ldyBTdWJqZWN0PHZvaWQ+KCkpO1xuICAgIGNvbnN0IGFwcGx5QmVoYXZpb3IgPSBwaXBlKG1hcFRvKGVmZmVjdElkKSwgdGFrZVVudGlsKGRlc3Ryb3kkKSk7XG4gICAgaWYgKGZuT3JPYmogIT0gbnVsbCkge1xuICAgICAgdGhpcy5vYnNlcnZhYmxlcyQubmV4dChcbiAgICAgICAgZnJvbShvYnNPclN1YikucGlwZShcbiAgICAgICAgICAvLyB0ZXJuYXJ5IGV4cHJlc3Npb24gaXMgdG8gaGVscCBUeXBlc2NyaXB0IGluZmVyIG92ZXJsb2Fkc1xuICAgICAgICAgIHR5cGVvZiBmbk9yT2JqID09PSAnZnVuY3Rpb24nID8gdGFwKGZuT3JPYmopIDogdGFwKGZuT3JPYmopLFxuICAgICAgICAgIGNhdGNoRXJyb3IoKGVycikgPT4ge1xuICAgICAgICAgICAgdGhpcy5lcnJvckhhbmRsZXI/LmhhbmRsZUVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm4gRU1QVFk7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgYXBwbHlCZWhhdmlvclxuICAgICAgICApXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9ic2VydmFibGVzJC5uZXh0KGZyb20ob2JzT3JTdWIpLnBpcGUoYXBwbHlCZWhhdmlvcikpO1xuICAgIH1cbiAgICByZXR1cm4gZWZmZWN0SWQ7XG4gIH1cblxuICAvKipcbiAgICogSW1wZXJhdGl2ZWx5IGNhbmNlbCBhIHNpZGUtZWZmZWN0IHdoaWxlIHRoZSBjb21wb25lbnQgaXMgc3RpbGwgcnVubmluZy5cbiAgICpcbiAgICogTm90ZSB0aGF0IGFsbCBlZmZlY3RzIGFyZSBhdXRvbWF0aWNhbGx5IGNhbmNlbGxlZCB3aGVuIGEgY29tcG9uZW50IGlzIGRlc3Ryb3llZCxcbiAgICogc28geW91IG1vc3Qgb2Z0ZW4gd29uJ3QgbmVlZCB0byBjYWxsIHRoaXMgbWV0aG9kLlxuICAgKiBAcGFyYW0gZWZmZWN0SWQgRWZmZWN0IElEIChyZXR1cm5lZCBieSByZWdpc3RlciBtZXRob2QpXG4gICAqL1xuICB1bnJlZ2lzdGVyKGVmZmVjdElkOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmRlc3Ryb3llcnNbZWZmZWN0SWRdPy5uZXh0KCk7XG4gIH1cblxuICAvKipcbiAgICogRmlyZXMgYSBzaWRlRWZmZWN0IHdoZW4gdGhlIGluc3RhbmNlcyBgT25EZXN0cm95YCBob29rIGlzIGZpcmVkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBlZmZlY3RzLnJlZ2lzdGVyT25EZXN0cm95KG1vZGUgPT4gbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2NvbG9yTW9kZScsIG1vZGUpKTtcbiAgICpcbiAgICogQHBhcmFtIHNpZGVFZmZlY3RcbiAgICovXG4gIHJlZ2lzdGVyT25EZXN0cm95KHNpZGVFZmZlY3Q6ICh2YWx1ZTogYm9vbGVhbikgPT4gdm9pZCk6IG51bWJlciB8IHZvaWQge1xuICAgIHJldHVybiB0aGlzLnJlZ2lzdGVyKHRoaXMub25EZXN0cm95JCwgc2lkZUVmZmVjdCk7XG4gIH1cblxuICAvKipcbiAgICogT3BlcmF0b3IgdGhhdCB1bnN1YnNjcmliZXMgYmFzZWQgb24gZW1pc3Npb24gb2YgYW4gcmVnaXN0ZXJlZCBlZmZlY3QuXG4gICAqXG4gICAqIEBOT1RJQ0VcbiAgICogVGhpcyBvcGVyYXRvciBoYXMgdG8gYmUgcGxhY2VkIGFsd2F5cyBhdCB0aGUgZW5kIG9mIHRoZSBvcGVyYXRvciBjaGFpbiAoYmVmb3JlIHRoZSBzdWJzY3JpcHRpb24pLlxuICAgKiBPdGhlcndpc2Ugd2UgbWF5IGxlYWsgYXMgYSBzdWJzZXF1ZW50IG9wZXJhdG9yIGNvdWxkIGluc3RhbnRpYXRlIG5ldyBvbmdvaW5nIE9ic2VydmFibGVzIHdoaWNoIHdpbGwgbm90IGdldCB1bnN1YnNjcmliZWQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGVmZmVjdElkMSA9IGVmZmVjdHMucmVnaXN0ZXIoXG4gICAqICAgY29sb3JNb2RlJC5zdWJzY3JpYmUobW9kZSA9PiBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnY29sb3JNb2RlJywgbW9kZSkpXG4gICAqICk7XG4gICAqXG4gICAqIHNvbWVWYWx1ZSQucGlwZShcbiAgICogICAgZWZmZWN0LnVudGlsRWZmZWN0KGVmZmVjdElkMSlcbiAgICogKVxuICAgKlxuICAgKi9cbiAgdW50aWxFZmZlY3QoZWZmZWN0SWQ6IG51bWJlcikge1xuICAgIHJldHVybiA8Vj4oc291cmNlOiBPYnNlcnZhYmxlPFY+KSA9PlxuICAgICAgc291cmNlLnBpcGUoXG4gICAgICAgIHVudGlsRGVzdHJveWVkKHRoaXMpLFxuICAgICAgICB0YWtlVW50aWwodGhpcy5lZmZlY3RzJC5waXBlKGZpbHRlcigoZUlkKSA9PiBlSWQgPT09IGVmZmVjdElkKSkpXG4gICAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5faG9va3MkLm5leHQoeyBkZXN0cm95OiB0cnVlIH0pO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gIH1cbn1cbiJdfQ==