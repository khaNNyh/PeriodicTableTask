import { ErrorHandler, Injectable, Optional } from '@angular/core';
import { actionProxyHandler } from './proxy';
import * as i0 from "@angular/core";
/**
 * @deprecated - use rxActions instead
 *
 * This class creates RxActions bound to Angular's DI life-cycles. This prevents memory leaks and optionally makes the instance reusable across the app.
 * The function has to be used inside an injection context.
 * If the consumer gets destroyed also the actions get destroyed automatically.
 *
 * @example
 * @Component({
 *   standalone: true,
 *   template: `...`,
 * })
 * export class AnyComponent {
 *   ui = rxActions<{search: string, refresh: void}>();
 * }
 */
export class RxActionFactory {
    errorHandler;
    subjects = [];
    constructor(errorHandler) {
        this.errorHandler = errorHandler;
    }
    /*
     * Returns a object based off of the provided typing with a separate setter `[prop](value: T[K]): void` and observable stream `[prop]$: Observable<T[K]>`;
     *
     * { search: string } => { search$: Observable<string>, search: (value: string) => void;}
     *
     * @example
     *
     * interface UIActions {
     *  search: string,
     *  submit: void
     * };
     *
     * const actions = new RxActionFactory<UIActions>().create();
     *
     * actions.search($event.target.value);
     * actions.search$.subscribe();
     *
     * As it is well typed the following things would not work:
     * actions.submit('not void'); // not void
     * actions.search(); // requires an argument
     * actions.search(42); // not a string
     * actions.search$.error(new Error('traraaa')); // not possible by typings as well as in code
     * actions.search = "string"; // not a setter. the proxy will throw an error pointing out that you have to call it
     *
     * @param transforms - A map of transform functions to apply on transformations to actions before emitting them.
     * This is very useful to clean up bloated templates and components. e.g. `[input]="$event?.target?.value"` => `[input]="$event"`
     *
     * @example
     * function coerceSearchActionParams(e: Event | string | number): string {
     *   if(e?.target?.value !== undefined) {
     *      return e?.target?.value + ''
     *   }
     *   return e + '';
     * }
     * const actions = getActions<search: string, submit: void>({search: coerceSearchActionParams, submit: (v: any) => void 0;});
     *
     * actions.search($event);
     * actions.search('string');
     * actions.search(42);
     * actions.submit('not void'); // does not error anymore
     * actions.search$.subscribe(); // string Observable
     *
     */
    create(transforms) {
        const subjectMap = {};
        const effectMap = {};
        this.subjects.push(subjectMap);
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        function signals() { }
        return new Proxy(signals, actionProxyHandler({
            subjectMap,
            effectMap,
            transformsMap: transforms,
            errorHandler: this.errorHandler ?? null,
        }));
    }
    destroy() {
        this.subjects.forEach((s) => {
            Object.values(s).forEach((subject) => subject.complete());
        });
    }
    /**
     * @internal
     * Internally used to clean up potential subscriptions to the subjects. (For Actions it is most probably a rare case but still important to care about)
     */
    ngOnDestroy() {
        this.destroy();
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: RxActionFactory, deps: [{ token: i0.ErrorHandler, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: RxActionFactory });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: RxActionFactory, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: i0.ErrorHandler, decorators: [{
                    type: Optional
                }] }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWN0aW9ucy5mYWN0b3J5LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vbGlicy9zdGF0ZS9hY3Rpb25zL3NyYy9saWIvYWN0aW9ucy5mYWN0b3J5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxZQUFZLEVBQUUsVUFBVSxFQUFhLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUU5RSxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxTQUFTLENBQUM7O0FBSzdDOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUVILE1BQU0sT0FBTyxlQUFlO0lBR2U7SUFGakMsUUFBUSxHQUFvQixFQUFxQixDQUFDO0lBRTFELFlBQXlDLFlBQTJCO1FBQTNCLGlCQUFZLEdBQVosWUFBWSxDQUFlO0lBQUcsQ0FBQztJQUV4RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BMENHO0lBQ0gsTUFBTSxDQUFxQyxVQUFjO1FBQ3ZELE1BQU0sVUFBVSxHQUFrQixFQUFtQixDQUFDO1FBQ3RELE1BQU0sU0FBUyxHQUFpQixFQUFrQixDQUFDO1FBQ25ELElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBRS9CLGdFQUFnRTtRQUNoRSxTQUFTLE9BQU8sS0FBVSxDQUFDO1FBRTNCLE9BQU8sSUFBSSxLQUFLLENBQ2QsT0FBaUMsRUFDakMsa0JBQWtCLENBQUM7WUFDakIsVUFBVTtZQUNWLFNBQVM7WUFDVCxhQUFhLEVBQUUsVUFBVTtZQUN6QixZQUFZLEVBQUUsSUFBSSxDQUFDLFlBQVksSUFBSSxJQUFJO1NBQ3hDLENBQUMsQ0FDdUIsQ0FBQztJQUM5QixDQUFDO0lBRUQsT0FBTztRQUNMLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7WUFDMUIsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxPQUFZLEVBQUUsRUFBRSxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO1FBQ2pFLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVEOzs7T0FHRztJQUNILFdBQVc7UUFDVCxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7SUFDakIsQ0FBQzswSEEvRVUsZUFBZTs4SEFBZixlQUFlOzsyRkFBZixlQUFlO2tCQUQzQixVQUFVOzswQkFJSSxRQUFRIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXJyb3JIYW5kbGVyLCBJbmplY3RhYmxlLCBPbkRlc3Ryb3ksIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBhY3Rpb25Qcm94eUhhbmRsZXIgfSBmcm9tICcuL3Byb3h5JztcbmltcG9ydCB7IEFjdGlvbnMsIEFjdGlvblRyYW5zZm9ybXMsIEVmZmVjdE1hcCwgUnhBY3Rpb25zIH0gZnJvbSAnLi90eXBlcyc7XG5cbnR5cGUgU3ViamVjdE1hcDxUPiA9IHsgW0sgaW4ga2V5b2YgVF06IFN1YmplY3Q8VFtLXT4gfTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZCAtIHVzZSByeEFjdGlvbnMgaW5zdGVhZFxuICpcbiAqIFRoaXMgY2xhc3MgY3JlYXRlcyBSeEFjdGlvbnMgYm91bmQgdG8gQW5ndWxhcidzIERJIGxpZmUtY3ljbGVzLiBUaGlzIHByZXZlbnRzIG1lbW9yeSBsZWFrcyBhbmQgb3B0aW9uYWxseSBtYWtlcyB0aGUgaW5zdGFuY2UgcmV1c2FibGUgYWNyb3NzIHRoZSBhcHAuXG4gKiBUaGUgZnVuY3Rpb24gaGFzIHRvIGJlIHVzZWQgaW5zaWRlIGFuIGluamVjdGlvbiBjb250ZXh0LlxuICogSWYgdGhlIGNvbnN1bWVyIGdldHMgZGVzdHJveWVkIGFsc28gdGhlIGFjdGlvbnMgZ2V0IGRlc3Ryb3llZCBhdXRvbWF0aWNhbGx5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBAQ29tcG9uZW50KHtcbiAqICAgc3RhbmRhbG9uZTogdHJ1ZSxcbiAqICAgdGVtcGxhdGU6IGAuLi5gLFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBbnlDb21wb25lbnQge1xuICogICB1aSA9IHJ4QWN0aW9uczx7c2VhcmNoOiBzdHJpbmcsIHJlZnJlc2g6IHZvaWR9PigpO1xuICogfVxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgUnhBY3Rpb25GYWN0b3J5PFQgZXh0ZW5kcyBQYXJ0aWFsPEFjdGlvbnM+PiBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgc3ViamVjdHM6IFN1YmplY3RNYXA8VD5bXSA9IFtdIGFzIFN1YmplY3RNYXA8VD5bXTtcblxuICBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBwcml2YXRlIHJlYWRvbmx5IGVycm9ySGFuZGxlcj86IEVycm9ySGFuZGxlcikge31cblxuICAvKlxuICAgKiBSZXR1cm5zIGEgb2JqZWN0IGJhc2VkIG9mZiBvZiB0aGUgcHJvdmlkZWQgdHlwaW5nIHdpdGggYSBzZXBhcmF0ZSBzZXR0ZXIgYFtwcm9wXSh2YWx1ZTogVFtLXSk6IHZvaWRgIGFuZCBvYnNlcnZhYmxlIHN0cmVhbSBgW3Byb3BdJDogT2JzZXJ2YWJsZTxUW0tdPmA7XG4gICAqXG4gICAqIHsgc2VhcmNoOiBzdHJpbmcgfSA9PiB7IHNlYXJjaCQ6IE9ic2VydmFibGU8c3RyaW5nPiwgc2VhcmNoOiAodmFsdWU6IHN0cmluZykgPT4gdm9pZDt9XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGludGVyZmFjZSBVSUFjdGlvbnMge1xuICAgKiAgc2VhcmNoOiBzdHJpbmcsXG4gICAqICBzdWJtaXQ6IHZvaWRcbiAgICogfTtcbiAgICpcbiAgICogY29uc3QgYWN0aW9ucyA9IG5ldyBSeEFjdGlvbkZhY3Rvcnk8VUlBY3Rpb25zPigpLmNyZWF0ZSgpO1xuICAgKlxuICAgKiBhY3Rpb25zLnNlYXJjaCgkZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgICogYWN0aW9ucy5zZWFyY2gkLnN1YnNjcmliZSgpO1xuICAgKlxuICAgKiBBcyBpdCBpcyB3ZWxsIHR5cGVkIHRoZSBmb2xsb3dpbmcgdGhpbmdzIHdvdWxkIG5vdCB3b3JrOlxuICAgKiBhY3Rpb25zLnN1Ym1pdCgnbm90IHZvaWQnKTsgLy8gbm90IHZvaWRcbiAgICogYWN0aW9ucy5zZWFyY2goKTsgLy8gcmVxdWlyZXMgYW4gYXJndW1lbnRcbiAgICogYWN0aW9ucy5zZWFyY2goNDIpOyAvLyBub3QgYSBzdHJpbmdcbiAgICogYWN0aW9ucy5zZWFyY2gkLmVycm9yKG5ldyBFcnJvcigndHJhcmFhYScpKTsgLy8gbm90IHBvc3NpYmxlIGJ5IHR5cGluZ3MgYXMgd2VsbCBhcyBpbiBjb2RlXG4gICAqIGFjdGlvbnMuc2VhcmNoID0gXCJzdHJpbmdcIjsgLy8gbm90IGEgc2V0dGVyLiB0aGUgcHJveHkgd2lsbCB0aHJvdyBhbiBlcnJvciBwb2ludGluZyBvdXQgdGhhdCB5b3UgaGF2ZSB0byBjYWxsIGl0XG4gICAqXG4gICAqIEBwYXJhbSB0cmFuc2Zvcm1zIC0gQSBtYXAgb2YgdHJhbnNmb3JtIGZ1bmN0aW9ucyB0byBhcHBseSBvbiB0cmFuc2Zvcm1hdGlvbnMgdG8gYWN0aW9ucyBiZWZvcmUgZW1pdHRpbmcgdGhlbS5cbiAgICogVGhpcyBpcyB2ZXJ5IHVzZWZ1bCB0byBjbGVhbiB1cCBibG9hdGVkIHRlbXBsYXRlcyBhbmQgY29tcG9uZW50cy4gZS5nLiBgW2lucHV0XT1cIiRldmVudD8udGFyZ2V0Py52YWx1ZVwiYCA9PiBgW2lucHV0XT1cIiRldmVudFwiYFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBmdW5jdGlvbiBjb2VyY2VTZWFyY2hBY3Rpb25QYXJhbXMoZTogRXZlbnQgfCBzdHJpbmcgfCBudW1iZXIpOiBzdHJpbmcge1xuICAgKiAgIGlmKGU/LnRhcmdldD8udmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgKiAgICAgIHJldHVybiBlPy50YXJnZXQ/LnZhbHVlICsgJydcbiAgICogICB9XG4gICAqICAgcmV0dXJuIGUgKyAnJztcbiAgICogfVxuICAgKiBjb25zdCBhY3Rpb25zID0gZ2V0QWN0aW9uczxzZWFyY2g6IHN0cmluZywgc3VibWl0OiB2b2lkPih7c2VhcmNoOiBjb2VyY2VTZWFyY2hBY3Rpb25QYXJhbXMsIHN1Ym1pdDogKHY6IGFueSkgPT4gdm9pZCAwO30pO1xuICAgKlxuICAgKiBhY3Rpb25zLnNlYXJjaCgkZXZlbnQpO1xuICAgKiBhY3Rpb25zLnNlYXJjaCgnc3RyaW5nJyk7XG4gICAqIGFjdGlvbnMuc2VhcmNoKDQyKTtcbiAgICogYWN0aW9ucy5zdWJtaXQoJ25vdCB2b2lkJyk7IC8vIGRvZXMgbm90IGVycm9yIGFueW1vcmVcbiAgICogYWN0aW9ucy5zZWFyY2gkLnN1YnNjcmliZSgpOyAvLyBzdHJpbmcgT2JzZXJ2YWJsZVxuICAgKlxuICAgKi9cbiAgY3JlYXRlPFUgZXh0ZW5kcyBBY3Rpb25UcmFuc2Zvcm1zPFQ+ID0ge30+KHRyYW5zZm9ybXM/OiBVKTogUnhBY3Rpb25zPFQsIFU+IHtcbiAgICBjb25zdCBzdWJqZWN0TWFwOiBTdWJqZWN0TWFwPFQ+ID0ge30gYXMgU3ViamVjdE1hcDxUPjtcbiAgICBjb25zdCBlZmZlY3RNYXA6IEVmZmVjdE1hcDxUPiA9IHt9IGFzIEVmZmVjdE1hcDxUPjtcbiAgICB0aGlzLnN1YmplY3RzLnB1c2goc3ViamVjdE1hcCk7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG4gICAgZnVuY3Rpb24gc2lnbmFscygpOiB2b2lkIHt9XG5cbiAgICByZXR1cm4gbmV3IFByb3h5KFxuICAgICAgc2lnbmFscyBhcyBhbnkgYXMgUnhBY3Rpb25zPFQsIFU+LFxuICAgICAgYWN0aW9uUHJveHlIYW5kbGVyKHtcbiAgICAgICAgc3ViamVjdE1hcCxcbiAgICAgICAgZWZmZWN0TWFwLFxuICAgICAgICB0cmFuc2Zvcm1zTWFwOiB0cmFuc2Zvcm1zLFxuICAgICAgICBlcnJvckhhbmRsZXI6IHRoaXMuZXJyb3JIYW5kbGVyID8/IG51bGwsXG4gICAgICB9KVxuICAgICkgYXMgYW55IGFzIFJ4QWN0aW9uczxULCBVPjtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJqZWN0cy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICBPYmplY3QudmFsdWVzKHMpLmZvckVhY2goKHN1YmplY3Q6IGFueSkgPT4gc3ViamVjdC5jb21wbGV0ZSgpKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogSW50ZXJuYWxseSB1c2VkIHRvIGNsZWFuIHVwIHBvdGVudGlhbCBzdWJzY3JpcHRpb25zIHRvIHRoZSBzdWJqZWN0cy4gKEZvciBBY3Rpb25zIGl0IGlzIG1vc3QgcHJvYmFibHkgYSByYXJlIGNhc2UgYnV0IHN0aWxsIGltcG9ydGFudCB0byBjYXJlIGFib3V0KVxuICAgKi9cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95KCk7XG4gIH1cbn1cbiJdfQ==