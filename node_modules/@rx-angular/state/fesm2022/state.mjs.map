{"version":3,"file":"state.mjs","sources":["../../../../libs/state/src/lib/provide-rx-state-config.ts","../../../../libs/state/src/lib/signal-state-proxy.ts","../../../../libs/state/src/lib/rx-state.service.ts","../../../../libs/state/src/lib/rx-state.ts","../../../../libs/state/src/state.ts"],"sourcesContent":["import { InjectionToken, Provider } from '@angular/core';\nimport {\n  AccumulationFn,\n  defaultAccumulator,\n} from '@rx-angular/state/selections';\nimport { queueScheduler, SchedulerLike } from 'rxjs';\n\nexport type RX_STATE_CONFIGS = 'Accumulator' | 'Scheduler';\n\ninterface RxStateConfigFn {\n  kind: RX_STATE_CONFIGS;\n  providers: Provider[];\n}\n\n/**\n * Injection token for the default accumulator function.\n *\n * @example\n * providers: [\n *  {\n *   provide: RX_ACCUMULATOR_FN,\n *   useValue: (state, slice) => ({ ...state, ...slice })\n *  }\n * ]\n */\nexport const RX_ACCUMULATOR_FN = new InjectionToken<AccumulationFn>(\n  'RX_ACCUMULATOR_FN',\n  {\n    providedIn: 'root',\n    factory: () => defaultAccumulator,\n  },\n);\n\n/**\n * Provider function to specify a custom `AccumulationFn` for `RxState` to use.\n * @param fn\n */\nexport function withAccumulatorFn(fn: AccumulationFn): RxStateConfigFn {\n  return {\n    kind: 'Accumulator',\n    providers: [{ provide: RX_ACCUMULATOR_FN, useValue: fn }],\n  };\n}\n\n/**\n * Injection token for the default state scheduler\n *\n * @example\n * providers: [\n *  {\n *   provide: RX_STATE_SCHEDULER,\n *   useValue: asapScheduler\n *  }\n * ]\n */\nexport const RX_STATE_SCHEDULER = new InjectionToken<SchedulerLike | 'sync'>(\n  'RX_STATE_SCHEDULER',\n  {\n    providedIn: 'root',\n    factory: () => queueScheduler,\n  },\n);\n\n/**\n * Provider function to specify a scheduler for `RxState` to perform state updates & emit new values.\n * @param scheduler\n */\nexport function withScheduler(\n  scheduler: SchedulerLike | 'sync',\n): RxStateConfigFn {\n  return {\n    kind: 'Scheduler',\n    providers: [{ provide: RX_STATE_SCHEDULER, useValue: scheduler }],\n  };\n}\n\n/**\n * Provider function to specify synchronous (no) scheduling for `RxState`. The state computations\n * will be fully synchronous instead of using the default `queueScheduler`\n */\nexport function withSyncScheduler(): RxStateConfigFn {\n  return {\n    kind: 'Scheduler',\n    providers: [{ provide: RX_STATE_SCHEDULER, useValue: 'sync' }],\n  };\n}\n\n/**\n * This function is used to provide the configuration for the rxState function.\n *\n * You can provide multiple configurations at once.\n *\n * You can use these functions to provide the configuration:\n * - withAccumulatorFn - to provide a custom accumulator function\n * - withScheduler - to provide a custom scheduler\n *\n */\nexport function provideRxStateConfig(\n  ...configs: RxStateConfigFn[]\n): Provider[] {\n  return flatten(configs.map((c) => c.providers));\n}\n\nfunction flatten<T>(arr: T[][]): T[] {\n  return arr.reduce((acc, val) => acc.concat(val), []);\n}\n","import {\n  DestroyRef,\n  inject,\n  Signal,\n  signal,\n  WritableSignal,\n} from '@angular/core';\nimport { takeUntilDestroyed } from '@angular/core/rxjs-interop';\nimport { select } from '@rx-angular/state/selections';\nimport { Observable } from 'rxjs';\n\nexport type SignalStateProxy<State extends object> = {\n  [K in keyof State]: Signal<State[K]>;\n};\n\nexport function createSignalStateProxy<State extends object>(\n  state$: Observable<State>,\n  stateFn: <K extends keyof State>(k: K) => State[K]\n) {\n  const destroyRef = inject(DestroyRef);\n\n  const signalState = {} as SignalStateProxy<State>;\n  return new Proxy<SignalStateProxy<State>>(signalState, {\n    get<K extends keyof State>(\n      target: SignalStateProxy<State>,\n      p: K | string | symbol\n    ): Signal<State[K]> {\n      let _signal = target[p as K];\n      if (!_signal) {\n        const val = stateFn(p as K);\n        _signal = signal(val);\n        target[p as K] = _signal;\n        state$\n          .pipe(select(p as K), takeUntilDestroyed(destroyRef))\n          .subscribe((val) => (_signal as WritableSignal<State[K]>).set(val));\n      }\n      return _signal;\n    },\n    has<K extends keyof State>(\n      target: SignalStateProxy<State>,\n      prop: K | string | symbol\n    ) {\n      return !!target[prop as K];\n    },\n    ownKeys(target) {\n      return [...Reflect.ownKeys(target)];\n    },\n    getOwnPropertyDescriptor(target, key) {\n      return {\n        enumerable: true,\n        configurable: true,\n      };\n    },\n    set(): boolean {\n      return true;\n    },\n  });\n}\n","import {\n  computed,\n  inject,\n  Injectable,\n  Injector,\n  isSignal,\n  OnDestroy,\n  Signal,\n} from '@angular/core';\nimport { toObservable, toSignal } from '@angular/core/rxjs-interop';\nimport {\n  AccumulationFn,\n  createAccumulationObservable,\n  createSideEffectObservable,\n  isKeyOf,\n  KeyCompareMap,\n  PickSlice,\n  safePluck,\n  select,\n} from '@rx-angular/state/selections';\nimport {\n  BehaviorSubject,\n  EMPTY,\n  isObservable,\n  Observable,\n  OperatorFunction,\n  Subject,\n  Subscribable,\n  Subscription,\n  Unsubscribable,\n} from 'rxjs';\nimport { catchError, map, tap } from 'rxjs/operators';\nimport {\n  RX_ACCUMULATOR_FN,\n  RX_STATE_SCHEDULER,\n} from './provide-rx-state-config';\nimport { createSignalStateProxy, SignalStateProxy } from './signal-state-proxy';\n\nexport type ProjectStateFn<Type> = (oldState: Type) => Partial<Type>;\n\nexport type ProjectValueFn<Type, Key extends keyof Type> = (\n  oldState: Type,\n) => Type[Key];\n\nexport type ProjectStateReducer<Type, Value> = (\n  oldState: Type,\n  value: Value,\n) => Partial<Type>;\n\nexport type ProjectValueReducer<Type, Key extends keyof Type, Value> = (\n  oldState: Type,\n  value: Value,\n) => Type[Key];\n\nexport type ReadOnly = 'get' | 'select' | 'computed' | 'signal';\n\n/**\n * @description\n * RxState is a light-weight reactive state management service for managing local state in angular.\n *\n * @example\n * Component({\n *   selector: 'app-stateful',\n *   template: `<div>{{ state$ | async | json }}</div>`,\n *   providers: [RxState]\n * })\n * export class StatefulComponent {\n *   readonly state$ = this.state.select();\n *\n *   constructor(private state: RxState<{ foo: string }>) {}\n * }\n *\n * @docsCategory RxState\n * @docsPage RxState\n */\n@Injectable()\nexport class RxState<State extends object>\n  implements OnDestroy, Subscribable<State>\n{\n  private subscription = new Subscription();\n\n  protected scheduler = inject(RX_STATE_SCHEDULER, { optional: true });\n\n  private accumulator = createAccumulationObservable<State>(\n    new Subject<Observable<Partial<State>>>(),\n    new Subject<Partial<State>>(),\n    new BehaviorSubject(inject(RX_ACCUMULATOR_FN)),\n    this.scheduler === 'sync' ? null : this.scheduler,\n  );\n  private effectObservable = createSideEffectObservable(\n    new Subject<Observable<unknown>>(),\n    this.scheduler === 'sync' ? null : this.scheduler,\n  );\n\n  private readonly injector = inject(Injector);\n\n  private signalStoreProxy: SignalStateProxy<State>;\n\n  /**\n   * @description\n   * The unmodified state exposed as `Observable<State>`. It is not shared, distinct or gets replayed.\n   * Use the `$` property if you want to read the state without having applied {@link stateful} to it.\n   */\n  readonly $: Observable<State> = this.accumulator.signal$;\n\n  /**\n   * @internal\n   */\n  constructor() {\n    this.subscription.add(this.subscribe());\n  }\n\n  /**\n   * @internal\n   */\n  ngOnDestroy(): void {\n    this.subscription.unsubscribe();\n  }\n\n  /**\n   * @description\n   *\n   * Return RxState in ReadOnly mode exposing only methods for reading state\n   * get(), select(), computed() and signal() methods.\n   * This can be helpful when you don't want others to write in your state.\n   *\n   * @example\n   * ```typescript\n   * const readOnlyState = state.asReadOnly();\n   * const getNum = state.get('num');\n   * const selectNum$ = state.select('num');\n   * ```\n   *\n   * @return Pick<RxState<State>, ReadOnly>\n   */\n  asReadOnly(): Pick<RxState<State>, ReadOnly> {\n    return {\n      get: this.get.bind(this),\n      select: this.select.bind(this),\n      computed: this.computed.bind(this),\n      signal: this.signal.bind(this),\n    };\n  }\n\n  /**\n   * @description\n   *\n   * Allows to customize state accumulation function.\n   * This can be helpful to implement deep updates and tackle other immutability problems in a custom way.\n   * @example\n   *\n   * ```typescript\n   * const myAccumulator = (state: MyState, slice: Partial<MyState>) => deepCopy(state, slice);\n   *\n   * this.state.setAccumulator(myAccumulator);\n   * ```\n   *\n   * @param {AccumulationFn} accumulatorFn\n   * @return void\n   *\n   * @deprecated\n   * Use `provideRxStateConfig` and provide the accumulator with the `withAccumulator` provider function.\n   * Will be removed in future versions.\n   */\n  setAccumulator(accumulatorFn: AccumulationFn): void {\n    this.accumulator.nextAccumulator(accumulatorFn);\n  }\n\n  /**\n   * @description\n   * Read from the state in imperative manner. Returns the state object in its current state.\n   *\n   * @example\n   * const { disabled } = state.get();\n   * if (!disabled) {\n   *   doStuff();\n   * }\n   *\n   * @return State\n   */\n  get(): State;\n\n  /**\n   * @description\n   * Read from the state in imperative manner by providing keys as parameters.\n   * Returns the part of state object.\n   *\n   * @example\n   * // Access a single property\n   * const bar = state.get('bar');\n   *\n   * // Access a nested property\n   * const foo = state.get('bar', 'foo');\n   *\n   * @param {KeyA} keyA\n   * @return State[KeyA]\n   */\n  get<KeyA extends keyof State>(keyA: KeyA): State[KeyA];\n\n  /** @internal **/\n  get<KeyA extends keyof State, KeyB extends keyof State[KeyA]>(\n    keyA: KeyA,\n    keyB: KeyB,\n  ): State[KeyA][KeyB];\n\n  /** @internal **/\n  get<\n    KeyA extends keyof State,\n    KeyB extends keyof State[KeyA],\n    KeyC extends keyof State[KeyA][KeyB],\n  >(keyA: KeyA, keyB: KeyB, keyC: KeyC): State[KeyA][KeyB][KeyC];\n\n  /** @internal **/\n  get<\n    KeyA extends keyof State,\n    KeyB extends keyof State[KeyA],\n    KeyC extends keyof State[KeyA][KeyB],\n    KeyD extends keyof State[KeyA][KeyB][KeyC],\n  >(\n    keyA: KeyA,\n    keyB: KeyB,\n    keyC: KeyC,\n    keyD: KeyD,\n  ): State[KeyA][KeyB][KeyC][KeyD];\n\n  /** @internal **/\n  get<\n    KeyA extends keyof State,\n    KeyB extends keyof State[KeyA],\n    KeyC extends keyof State[KeyA][KeyB],\n    KeyD extends keyof State[KeyA][KeyB][KeyC],\n    KeyE extends keyof State[KeyA][KeyB][KeyC][KeyD],\n  >(\n    keyA: KeyA,\n    keyB: KeyB,\n    keyC: KeyC,\n    keyD: KeyD,\n    keyE: KeyE,\n  ): State[KeyA][KeyB][KeyC][KeyD][KeyE];\n\n  /** @internal **/\n  get<\n    KeyA extends keyof State,\n    KeyB extends keyof State[KeyA],\n    KeyC extends keyof State[KeyA][KeyB],\n    KeyD extends keyof State[KeyA][KeyB][KeyC],\n    KeyE extends keyof State[KeyA][KeyB][KeyC][KeyD],\n    KeyF extends keyof State[KeyA][KeyB][KeyC][KeyD][KeyE],\n  >(\n    keyA: KeyA,\n    keyB: KeyB,\n    keyC: KeyC,\n    keyD: KeyD,\n    keyE: KeyE,\n    keyF: KeyF,\n  ): State[KeyA][KeyB][KeyC][KeyD][KeyE][KeyF];\n\n  /** @internal **/\n  get<\n    KeyA extends keyof State,\n    KeyB extends keyof State[KeyA],\n    KeyC extends keyof State[KeyA][KeyB],\n    KeyD extends keyof State[KeyA][KeyB][KeyC],\n    KeyE extends keyof State[KeyA][KeyB][KeyC][KeyD],\n    KeyF extends keyof State[KeyA][KeyB][KeyC][KeyD][KeyE],\n  >(\n    ...keys:\n      | [KeyA]\n      | [KeyA, KeyB]\n      | [KeyA, KeyB, KeyC]\n      | [KeyA, KeyB, KeyC, KeyD]\n      | [KeyA, KeyB, KeyC, KeyD, KeyE]\n      | [KeyA, KeyB, KeyC, KeyD, KeyE, KeyF]\n  ):\n    | State\n    | State[KeyA]\n    | State[KeyA][KeyB]\n    | State[KeyA][KeyB][KeyC]\n    | State[KeyA][KeyB][KeyC][KeyD]\n    | State[KeyA][KeyB][KeyC][KeyD][KeyE]\n    | State[KeyA][KeyB][KeyC][KeyD][KeyE][KeyF] {\n    const hasStateAnyKeys = Object.keys(this.accumulator.state).length > 0;\n    if (!!keys && keys.length) {\n      return safePluck(this.accumulator.state, keys);\n    } else {\n      return hasStateAnyKeys\n        ? this.accumulator.state\n        : (undefined as unknown as State);\n    }\n  }\n\n  /**\n   * @description\n   * Manipulate one or many properties of the state by providing\n   * a `Partial<State>`state or a `ProjectionFunction<State>`.\n   *\n   * @example\n   * // Update one or many properties of the state by providing a `Partial<State>`\n   *\n   * const partialState = {\n   *   foo: 'bar',\n   *   bar: 5\n   * };\n   * state.set(partialState);\n   *\n   * // Update one or many properties of the state by providing a `ProjectionFunction<State>`\n   *\n   * const reduceFn = oldState => ({\n   *   bar: oldState.bar + 5\n   * });\n   * state.set(reduceFn);\n   *\n   * @param {Partial<State>|ProjectStateFn<State>} stateOrProjectState\n   * @return void\n   */\n  set(stateOrProjectState: Partial<State> | ProjectStateFn<State>): void;\n\n  /**\n   * @description\n   * Manipulate a single property of the state by the property name and a `ProjectionFunction<State>`.\n   *\n   * @example\n   * const reduceFn = oldState => oldState.bar + 5;\n   * state.set('bar', reduceFn);\n   *\n   * @param {Key} key\n   * @param {ProjectValueFn<State, Key>} projectSlice\n   * @return void\n   */\n  set<Key extends keyof State, Object>(\n    key: Key,\n    projectSlice: ProjectValueFn<State, Key>,\n  ): void;\n  /**\n   * @internal\n   */\n  set<Key extends keyof State>(\n    keyOrStateOrProjectState: Partial<State> | ProjectStateFn<State> | Key,\n    stateOrSliceProjectFn?: ProjectValueFn<State, Key>,\n  ): void {\n    if (\n      typeof keyOrStateOrProjectState === 'object' &&\n      stateOrSliceProjectFn === undefined\n    ) {\n      this.accumulator.nextSlice(keyOrStateOrProjectState);\n      return;\n    }\n\n    if (\n      typeof keyOrStateOrProjectState === 'function' &&\n      stateOrSliceProjectFn === undefined\n    ) {\n      this.accumulator.nextSlice(\n        keyOrStateOrProjectState(this.accumulator.state),\n      );\n      return;\n    }\n\n    if (\n      isKeyOf<State>(keyOrStateOrProjectState) &&\n      typeof stateOrSliceProjectFn === 'function'\n    ) {\n      const state: Partial<State> = {};\n      state[keyOrStateOrProjectState] = stateOrSliceProjectFn(\n        this.accumulator.state,\n      );\n      this.accumulator.nextSlice(state);\n      return;\n    }\n\n    throw new Error('wrong params passed to set');\n  }\n\n  /**\n   * @description\n   * Connect an `Observable<Partial<State>>` to the state `State`.\n   * Any change emitted by the source will get merged into the state.\n   * Subscription handling is done automatically.\n   *\n   * @example\n   * const sliceToAdd$ = interval(250).pipe(mapTo({\n   *   bar: 5,\n   *   foo: 'foo'\n   * });\n   * state.connect(sliceToAdd$);\n   * // every 250ms the properties bar and foo get updated due to the emission of sliceToAdd$\n   *\n   * // Additionally you can provide a `projectionFunction` to access the current state object and do custom mappings.\n   *\n   * const sliceToAdd$ = interval(250).pipe(mapTo({\n   *   bar: 5,\n   *   foo: 'foo'\n   * });\n   * state.connect(sliceToAdd$, (state, slice) => state.bar += slice.bar);\n   * // every 250ms the properties bar and foo get updated due to the emission of sliceToAdd$. Bar will increase by\n   * // 5 due to the projectionFunction\n   *\n   *  @param {Observable<Partial<State>>} inputOrSlice$\n   *  @return void\n   */\n  connect(inputOrSlice$: Observable<Partial<State>>): void;\n\n  /**\n   * @description\n   * Connect a `Signal<Partial<State>>` to the state `State`.\n   * Any change emitted by the source will get merged into the state.\n   *\n   * @example\n   * const partialState = signal({ foo: 'foo', bar: 5 });\n   * state.connect(partialState);\n   *\n   *  @param {Signal<Partial<State>>} signal\n   *  @return void\n   */\n  connect(signal: Signal<Partial<State>>): void;\n\n  /**\n   * @description\n   * Connect an `Observable<Value>` to the state `State`.\n   * Any change emitted by the source will get forwarded to project function and merged into the state.\n   * Subscription handling is done automatically.\n   *\n   * You have to provide a `projectionFunction` to access the current state object and do custom mappings.\n   *\n   * @example\n   * const sliceToAdd$ = interval(250);\n   * state.connect(sliceToAdd$, (type, value) => ({bar: value}));\n   * // every 250ms the property bar get updated due to the emission of sliceToAdd$\n   *\n   * @param {Observable<Value>} inputOrSlice$\n   * @param {ProjectStateReducer<State, Value>} projectFn\n   * @return void\n   */\n  connect<Value>(\n    inputOrSlice$: Observable<Value>,\n    projectFn: ProjectStateReducer<State, Value>,\n  ): void;\n\n  /**\n   * @description\n   * Connect a `Signal<Value>` to the state `State`.\n   * Any change emitted by the source will get forwarded to the project function and merged into the state.\n   *\n   * You have to provide a `projectionFunction` to access the current state object and do custom mappings.\n   *\n   * @example\n   * const signalSlice = signal(5);\n   * state.connect(signalSlice, (type, value) => ({bar: value}));\n   *\n   * @param {Signal<Value>} signal\n   * @param {ProjectStateReducer<State, Value>} projectFn\n   * @return void\n   */\n  connect<Value>(\n    signal: Signal<Value>,\n    projectFn: ProjectStateReducer<State, Value>,\n  ): void;\n\n  /**\n   *\n   * @description\n   * Connect an `Observable<State[Key]>` source to a specific property `Key` in the state `State`.\n   * Any emitted change will update this specific property in the state.\n   * Subscription handling is done automatically.\n   *\n   * @example\n   * const myTimer$ = interval(250);\n   * state.connect('timer', myTimer$);\n   * // every 250ms the property timer will get updated\n   * @param {Key} key\n   * @param {Observable<State[Key]>} slice$\n   *\n   * @return void\n   */\n  connect<Key extends keyof State>(\n    key: Key,\n    slice$: Observable<State[Key]>,\n  ): void;\n\n  /**\n   *\n   * @description\n   * Connect a `Signal<State[Key]>` source to a specific property `Key` in the state `State`.\n   * Any emitted change will update this specific property in the state.\n   *\n   * @example\n   * const currentTime = signal(Date.now())\n   * state.connect('currentTime', currentTime);\n   *\n   * @param {Key} key\n   * @param {Signal<State[Key]>} signal\n   *\n   * @return void\n   */\n  connect<Key extends keyof State>(key: Key, signal: Signal<State[Key]>): void;\n\n  /**\n   * @description\n   * Connect an `Observable<Value>` source to a specific property in the state. Additionally, you can provide a\n   * `projectionFunction` to access the current state object on every emission of your connected `Observable`.\n   * Any change emitted by the source will get merged into the state.\n   * Subscription handling is done automatically.\n   *\n   * @example\n   * const myTimer$ = interval(250);\n   * state.connect('timer', myTimer$, (state, timerChange) => state.timer += timerChange);\n   * // every 250ms the property timer will get updated\n   *\n   * @param {Key} key\n   * @param {Observable<Value>} input$\n   * @param {ProjectValueReducer<State, Key, Value>} projectSliceFn\n   *\n   * @return void\n   */\n  connect<Key extends keyof State, Value>(\n    key: Key,\n    input$: Observable<Value>,\n    projectSliceFn: ProjectValueReducer<State, Key, Value>,\n  ): void;\n\n  /**\n   *\n   * @description\n   * Connect a `Signal<Value>` source to a specific property in the state. Additionally, you can provide a\n   * `projectionFunction` to access the current state object on every emission of your connected `Observable`.\n   * Any change emitted by the source will get merged into the state.\n   * Subscription handling is done automatically.\n   *\n   * @example\n   * const currentTime = signal(Date.now())\n   * state.connect('currentTime', currentTime, (state, currentTime) => state.currentTime = currentTime);\n   *\n   * @param {Key} key\n   * @param {Signal<Value>} signal\n   * @param {ProjectValueReducer<State, Key, Value>} projectSliceFn\n   *\n   * @return void\n   */\n  connect<Key extends keyof State, Value>(\n    key: Key,\n    signal: Signal<Value>,\n    projectSliceFn: ProjectValueReducer<State, Key, Value>,\n  ): void;\n\n  /**\n   * @internal\n   */\n  connect<Key extends keyof State, Value extends Partial<State>>(\n    keyOrInputOrSlice$:\n      | Key\n      | Observable<Partial<State> | Value>\n      | Signal<Partial<State> | Value>,\n    projectOrSlices$?:\n      | ProjectStateReducer<State, Value>\n      | Observable<State[Key] | Value>\n      | Signal<State[Key] | Value>,\n    projectValueFn?: ProjectValueReducer<State, Key, Value>,\n  ): void {\n    /**\n     * From top to bottom the overloads are handled.\n     */\n    if (\n      isObservable(keyOrInputOrSlice$) &&\n      !projectOrSlices$ &&\n      !projectValueFn\n    ) {\n      this.accumulator.nextSliceObservable(keyOrInputOrSlice$);\n      return;\n    }\n\n    if (isSignal(keyOrInputOrSlice$) && !projectOrSlices$ && !projectValueFn) {\n      this.accumulator.nextSliceObservable(\n        toObservable(keyOrInputOrSlice$, { injector: this.injector }),\n      );\n      return;\n    }\n\n    if (\n      isObservable(keyOrInputOrSlice$) &&\n      projectOrSlices$ &&\n      typeof projectOrSlices$ === 'function' &&\n      !projectValueFn\n    ) {\n      const projectionStateFn = projectOrSlices$;\n      const slice$ = keyOrInputOrSlice$.pipe(\n        map((v) => projectionStateFn(this.accumulator.state, v as Value)),\n      );\n      this.accumulator.nextSliceObservable(slice$ as Observable<Value>);\n      return;\n    }\n\n    if (\n      isSignal(keyOrInputOrSlice$) &&\n      projectOrSlices$ &&\n      typeof projectOrSlices$ === 'function' &&\n      !projectValueFn\n    ) {\n      const projectionStateFn = projectOrSlices$;\n      const slice$ = toObservable(keyOrInputOrSlice$, {\n        injector: this.injector,\n      }).pipe(\n        map((v) => projectionStateFn(this.accumulator.state, v as Value)),\n      );\n      this.accumulator.nextSliceObservable(slice$ as Observable<Value>);\n      return;\n    }\n\n    if (\n      isKeyOf<State>(keyOrInputOrSlice$) &&\n      isObservable(projectOrSlices$) &&\n      !projectValueFn\n    ) {\n      const slice$ = projectOrSlices$.pipe(\n        map((value) => ({ ...{}, [keyOrInputOrSlice$]: value })),\n      );\n      this.accumulator.nextSliceObservable(slice$);\n      return;\n    }\n\n    if (\n      isKeyOf<State>(keyOrInputOrSlice$) &&\n      isSignal(projectOrSlices$) &&\n      !projectValueFn\n    ) {\n      const slice$ = toObservable(projectOrSlices$, {\n        injector: this.injector,\n      }).pipe(map((value) => ({ ...{}, [keyOrInputOrSlice$]: value })));\n      this.accumulator.nextSliceObservable(slice$);\n      return;\n    }\n\n    if (\n      projectValueFn &&\n      typeof projectValueFn === 'function' &&\n      isKeyOf<State>(keyOrInputOrSlice$) &&\n      isObservable(projectOrSlices$)\n    ) {\n      const key: Key = keyOrInputOrSlice$;\n      const slice$ = projectOrSlices$.pipe(\n        map((value) => ({\n          ...{},\n          [key]: projectValueFn(this.get(), value as Value),\n        })),\n      );\n      this.accumulator.nextSliceObservable(slice$);\n      return;\n    }\n\n    if (\n      projectValueFn &&\n      typeof projectValueFn === 'function' &&\n      isKeyOf(keyOrInputOrSlice$) &&\n      isSignal(projectOrSlices$)\n    ) {\n      const key: Key = keyOrInputOrSlice$;\n      const slice$ = toObservable(projectOrSlices$, {\n        injector: this.injector,\n      }).pipe(\n        map((value) => ({\n          ...{},\n          [key]: projectValueFn(this.get(), value as Value),\n        })),\n      );\n      this.accumulator.nextSliceObservable(slice$);\n      return;\n    }\n\n    throw new Error('wrong params passed to connect');\n  }\n\n  /**\n   * @description\n   * Returns the state as cached and distinct `Observable<Type>`.\n   * This way you don't have to think about\n   * **late subscribers**, **multiple subscribers** or **multiple emissions** of the same value\n   *\n   * @example\n   * const state$ = state.select();\n   * state$.subscribe(state => doStuff(state));\n   *\n   * @returns Observable<TType>\n   */\n  select(): Observable<State>;\n\n  /**\n   * @description\n   * Returns the state as cached and distinct `Observable<TypeA>`. Accepts arbitrary\n   * [rxjs operators](https://rxjs-dev.firebaseapp.com/guide/operators)\n   * to enrich the selection with reactive composition.\n   *\n   * @example\n   * const profilePicture$ = state.select(\n   *  map((state) => state.profilePicture),\n   *  switchMap(profilePicture => mapImageAsync(profilePicture))\n   * );\n   * @param op { OperatorFunction<Type, TypeA> }\n   * @returns Observable<TypeA>\n   */\n  select<TypeA = State>(op: OperatorFunction<State, TypeA>): Observable<TypeA>;\n\n  /**\n   * @internal\n   */\n  select<TypeA = State, TypeB = TypeA>(\n    op1: OperatorFunction<State, TypeA>,\n    op2: OperatorFunction<TypeA, TypeB>,\n  ): Observable<TypeB>;\n\n  /**\n   * @internal\n   */\n  select<TypeA = State, TypeB = TypeA, TypeC = TypeB>(\n    op1: OperatorFunction<State, TypeA>,\n    op2: OperatorFunction<TypeA, TypeB>,\n    op3: OperatorFunction<TypeB, TypeC>,\n  ): Observable<TypeC>;\n\n  /**\n   * @internal\n   */\n  select<TypeA = State, TypeB = TypeA, TypeC = TypeB, TypeD = TypeC>(\n    op1: OperatorFunction<State, TypeA>,\n    op2: OperatorFunction<TypeA, TypeB>,\n    op3: OperatorFunction<TypeB, TypeC>,\n    op4: OperatorFunction<TypeC, TypeD>,\n  ): Observable<TypeD>;\n\n  /**\n   * @internal\n   */\n  select<\n    TypeA = State,\n    TypeB = TypeA,\n    TypeC = TypeB,\n    TypeD = TypeC,\n    TypeE = TypeD,\n  >(\n    op1: OperatorFunction<State, TypeA>,\n    op2: OperatorFunction<TypeA, TypeB>,\n    op3: OperatorFunction<TypeB, TypeC>,\n    op4: OperatorFunction<TypeC, TypeD>,\n    op5: OperatorFunction<TypeD, TypeE>,\n  ): Observable<TypeE>;\n\n  /**\n   * @description\n   * Transform a slice of the state by providing keys and map function.\n   * Returns result of applying function to state slice as cached and distinct `Observable<Value>`.\n   *\n   * @example\n   * // Project state slice\n   * const text$ = state.select(\n   *   ['query', 'results'],\n   *   ({ query, results }) => `${results.length} results found for \"${query}\"`\n   * );\n   *\n   * @param {Key[]} keys\n   * @param {(slice: PickSlice<Type, Key>) => Value} fn\n   * @param {KeyCompareMap<Pick<Type, Key>>} keyCompareMap\n   *\n   * @return Observable<Value>\n   */\n  select<Key extends keyof State, Value>(\n    keys: Key[],\n    fn?: (slice: PickSlice<State, Key>) => Value,\n    keyCompareMap?: KeyCompareMap<Pick<State, Key>>,\n  ): Observable<Value>;\n\n  /**\n   * @description\n   * Transform a single property of the state by providing a key and map function.\n   * Returns result of applying function to state property as cached and distinct `Observable<Value>`.\n   *\n   * @example\n   * // Project state based on single property\n   * const foo$ = state.select('bar', bar => `bar equals ${bar}`);\n   *\n   * @param {Key} key\n   * @param {(val: Type[Key]) => Value} fn\n   *\n   * @return Observable<Value>\n   */\n  select<Key extends keyof State, Value>(\n    key: Key,\n    fn: (val: State[Key]) => Value,\n  ): Observable<Value>;\n\n  /**\n   * @description\n   * Access a single property of the state by providing keys.\n   * Returns a single property of the state as cached and distinct `Observable<State[KeyA]>`.\n   *\n   * @example\n   * // Access a single property\n   *\n   * const bar$ = state.select('bar');\n   *\n   * // Access a nested property\n   *\n   * const foo$ = state.select('bar', 'foo');\n   *\n   * @return Observable<Type[KeyA]>\n   */\n  select<KeyA extends keyof State>(keyA: KeyA): Observable<State[KeyA]>;\n\n  /**\n   * @internal\n   */\n  select<KeyA extends keyof State, KeyB extends keyof State[KeyA]>(\n    keyA: KeyA,\n    keyB: KeyB,\n  ): Observable<State[KeyA][KeyB]>;\n\n  /**\n   * @internal\n   */\n  select<\n    KeyA extends keyof State,\n    KeyB extends keyof State[KeyA],\n    KeyC extends keyof State[KeyA][KeyB],\n  >(keyA: KeyA, keyB: KeyB, keyC: KeyC): Observable<State[KeyA][KeyB][KeyC]>;\n\n  /**\n   * @internal\n   */\n  select<\n    KeyA extends keyof State,\n    KeyB extends keyof State[KeyA],\n    KeyC extends keyof State[KeyA][KeyB],\n    KeyD extends keyof State[KeyA][KeyB][KeyC],\n  >(\n    keyA: KeyA,\n    keyB: KeyB,\n    keyC: KeyC,\n    keyD: KeyD,\n  ): Observable<State[KeyA][KeyB][KeyC][KeyD]>;\n\n  /**\n   * @internal\n   */\n  select<\n    KeyA extends keyof State,\n    KeyB extends keyof State[KeyA],\n    KeyC extends keyof State[KeyA][KeyB],\n    KeyD extends keyof State[KeyA][KeyB][KeyC],\n    KeyE extends keyof State[KeyA][KeyB][KeyC][KeyD],\n  >(\n    keyA: KeyA,\n    keyB: KeyB,\n    keyC: KeyC,\n    keyD: KeyD,\n    keyE: KeyE,\n  ): Observable<State[KeyA][KeyB][KeyC][KeyD][KeyE]>;\n\n  /**\n   * @internal\n   */\n  select<\n    KeyA extends keyof State,\n    KeyB extends keyof State[KeyA],\n    KeyC extends keyof State[KeyA][KeyB],\n    KeyD extends keyof State[KeyA][KeyB][KeyC],\n    KeyE extends keyof State[KeyA][KeyB][KeyC][KeyD],\n    KeyF extends keyof State[KeyA][KeyB][KeyC][KeyD][KeyE],\n  >(\n    keyA: KeyA,\n    keyB: KeyB,\n    keyC: KeyC,\n    keyD: KeyD,\n    keyE: KeyE,\n    keyF: KeyF,\n  ): Observable<State[KeyA][KeyB][KeyC][KeyD][KeyE][KeyF]>;\n\n  /**\n   * @internal\n   */\n  select<Return>(\n    ...args:\n      | OperatorFunction<State, unknown>[]\n      | string[]\n      | [k: string, fn: (val: unknown) => unknown]\n      | [\n          keys: string[],\n          fn?: (slice: unknown) => unknown,\n          keyCompareMap?: KeyCompareMap<State>,\n        ]\n  ): Observable<State | Return> {\n    return this.accumulator.state$.pipe(\n      select(...(args as Parameters<typeof select>)),\n    );\n  }\n\n  /**\n   * @description\n   * Returns a signal of the given key. It's first value is determined by the\n   * current keys value in RxState. Whenever the key gets updated, the signal\n   * will also be updated accordingly.\n   *\n   * @example\n   * const fooSignal = state.signal('foo');\n   *\n   * @param {Key} key\n   *\n   * @return Signal<State[Key]>\n   */\n  signal<Key extends keyof State>(key: Key): Signal<State[Key]> {\n    return this.signalStoreProxy[key];\n  }\n\n  /**\n   * @description\n   * Lets you create a computed signal based off multiple keys stored in RxState.\n   *\n   * @example\n   * const computedSignal = state.computed((s) => s.foo + s.bar);\n   *\n   * @param {(slice: SignalStateProxy<Type>) => ComputedType} fn\n   * @return Signal<ComputedType>\n   */\n  computed<ComputedType>(\n    fn: (slice: SignalStateProxy<State>) => ComputedType,\n  ): Signal<ComputedType> {\n    return computed(() => {\n      return fn(this.signalStoreProxy);\n    });\n  }\n\n  /**\n   * @description\n   * Lets you create a computed signal derived from state and rxjs operators.\n   *\n   * @throws If the initial value is not provided and the signal is not sync.\n   * Use startWith() to provide an initial value.\n   *\n   * @example\n   * const computedSignal = state.computedFrom(\n   *    map(state => state.foo),\n   *    filter(foo => foo > 5)\n   *  );\n   *\n   * @param op1 { OperatorFunction<Type, TypeA> }\n   * @returns Signal<TypeA>\n   */\n  computedFrom<TypeA = State>(\n    op1: OperatorFunction<State, TypeA>,\n  ): Signal<TypeA>;\n\n  /** @internal */\n  computedFrom<TypeA = State, TypeB = TypeA>(\n    op1: OperatorFunction<State, TypeA>,\n    op2: OperatorFunction<TypeA, TypeB>,\n  ): Signal<TypeB>;\n\n  /** @internal */\n  computedFrom<TypeA = State, TypeB = TypeA, TypeC = TypeB>(\n    op1: OperatorFunction<State, TypeA>,\n    op2: OperatorFunction<TypeA, TypeB>,\n    op3: OperatorFunction<TypeB, TypeC>,\n  ): Signal<TypeC>;\n\n  /** @internal */\n  computedFrom<TypeA = State, TypeB = TypeA, TypeC = TypeB, TypeD = TypeC>(\n    op1: OperatorFunction<State, TypeA>,\n    op2: OperatorFunction<TypeA, TypeB>,\n    op3: OperatorFunction<TypeB, TypeC>,\n    op4: OperatorFunction<TypeC, TypeD>,\n  ): Signal<TypeD>;\n\n  /** @internal */\n  computedFrom<\n    TypeA = State,\n    TypeB = TypeA,\n    TypeC = TypeB,\n    TypeD = TypeC,\n    TypeE = TypeD,\n  >(\n    op1: OperatorFunction<State, TypeA>,\n    op2: OperatorFunction<TypeA, TypeB>,\n    op3: OperatorFunction<TypeB, TypeC>,\n    op4: OperatorFunction<TypeC, TypeD>,\n    op5: OperatorFunction<TypeD, TypeE>,\n  ): Signal<TypeE>;\n\n  /** @internal */\n  computedFrom<Type>(...ops: OperatorFunction<State, unknown>[]): Signal<Type> {\n    return toSignal<Type>(this.select(...(ops as Parameters<typeof select>)), {\n      injector: this.injector,\n      requireSync: true,\n    });\n  }\n\n  /**\n   * @description\n   * Manages side-effects of your state. Provide an `Observable<any>`\n   * **side-effect** and an optional `sideEffectFunction`.\n   * Subscription handling is done automatically.\n   *\n   * @example\n   * // Directly pass an observable side-effect\n   * const localStorageEffect$ = changes$.pipe(\n   *  tap(changes => storeChanges(changes))\n   * );\n   * state.hold(localStorageEffect$);\n   *\n   * // Pass an additional `sideEffectFunction`\n   *\n   * const localStorageEffectFn = changes => storeChanges(changes);\n   * state.hold(changes$, localStorageEffectFn);\n   *\n   * @param {Observable<SideEffect>} obsOrObsWithSideEffect\n   * @param {function} [sideEffectFn]\n   *\n   * @return void\n   */\n  hold<SideEffect>(\n    obsOrObsWithSideEffect: Observable<SideEffect>,\n    sideEffectFn?: (arg: SideEffect) => void,\n  ): void {\n    const sideEffect = obsOrObsWithSideEffect.pipe(catchError((e) => EMPTY));\n    if (typeof sideEffectFn === 'function') {\n      this.effectObservable.nextEffectObservable(\n        sideEffect.pipe(tap(sideEffectFn)),\n      );\n      return;\n    }\n    this.effectObservable.nextEffectObservable(sideEffect);\n  }\n\n  /**\n   * @internal\n   */\n  subscribe(): Unsubscribable {\n    const subscription = new Subscription();\n    subscription.add(this.accumulator.subscribe());\n    subscription.add(this.effectObservable.subscribe());\n    this.signalStoreProxy = createSignalStateProxy<State>(\n      this.$,\n      this.get.bind(this),\n    );\n    return subscription;\n  }\n}\n","import { assertInInjectionContext, DestroyRef, inject } from '@angular/core';\nimport { RxState as LegacyState } from './rx-state.service';\n\nexport type RxState<T extends object> = Pick<\n  LegacyState<T>,\n  | 'get'\n  | 'select'\n  | 'connect'\n  | 'set'\n  | '$'\n  | 'setAccumulator'\n  | 'signal'\n  | 'computed'\n  | 'computedFrom'\n>;\n\nexport type RxStateSetupFn<State extends object> = (\n  rxState: Pick<\n    RxState<State>,\n    'connect' | 'set' | 'get' | 'select' | 'setAccumulator'\n  >\n) => void;\n\n/**\n * @description\n * Functional way to setup state management with RxState. It's a wrapper around RxState that automatically get\n *   destroyed.\n *\n * @example\n * ```ts\n * import { rxState } from '@rx-angular/state';\n *\n * Component({})\n * export class FooComponent {\n *  readonly state = rxState<{ count: number }>(({ set }) => set({ count: 0 }));\n * }\n * ```\n *\n * @param setupFn\n * @returns RxState instance\n *\n *\n *\n * @docsCategory RxState\n * @docsPage RxState\n *\n */\nexport function rxState<State extends object>(\n  setupFn?: RxStateSetupFn<State>\n): RxState<State> {\n  assertInInjectionContext(rxState);\n\n  const legacyState = new LegacyState<State>();\n  const destroyRef = inject(DestroyRef);\n\n  destroyRef.onDestroy(() => legacyState.ngOnDestroy());\n\n  const state: RxState<State> = {\n    get: legacyState.get.bind(legacyState),\n    set: legacyState.set.bind(legacyState),\n    connect: legacyState.connect.bind(legacyState),\n    select: legacyState.select.bind(legacyState),\n    signal: legacyState.signal.bind(legacyState),\n    computed: legacyState.computed.bind(legacyState),\n    computedFrom: legacyState.computedFrom.bind(legacyState),\n    $: legacyState.$,\n    setAccumulator: legacyState.setAccumulator.bind(legacyState),\n  };\n\n  setupFn?.(state);\n\n  return state;\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":["LegacyState"],"mappings":"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"}