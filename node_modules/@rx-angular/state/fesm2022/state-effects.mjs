import * as i0 from '@angular/core';
import { Injectable, Optional, assertInInjectionContext, inject, ErrorHandler, DestroyRef } from '@angular/core';
import { Subject, Subscription, pipe, from, EMPTY } from 'rxjs';
import { filter, take, shareReplay, map, takeUntil, mergeAll, share, mapTo, tap, catchError } from 'rxjs/operators';

function isSingleShotHookNameGuard(name) {
    return !!name && typeof name === 'string' && name !== '';
}
/**
 * @internal
 * Operator to filter values for single shot observables
 */
const singleShotOperators = (o$) => o$.pipe(filter((v) => v === true), take(1), shareReplay());
/**
 * This is an operator that is used to listen to Angular lifecycle hooks.
 * It plucks a defined lefe cycle name `HookProps` and forwards values for the particular value and in the behavior of the hook e.g. single shot
 *
 * @param name
 */
function toHook(name) {
    const operators = isSingleShotHookNameGuard(name)
        ? singleShotOperators
        : (o) => o;
    return (o$) => o$.pipe(map((p) => p[name]), operators);
}
/**
 * This operator can be used to take instances that implements `OnDestroy$` and unsubscribes from the given Observable when the instances
 * `onDestroy$` Observable emits.
 *
 * @param instanceWithLifecycle
 */
function untilDestroyed(instanceWithLifecycle) {
    return (source) => source.pipe(takeUntil(instanceWithLifecycle.onDestroy$));
}

/**
 * @deprecated - use rxEffects instead
 *
 * Reduces subscription boilerplate for performing observable-based side-effects in components.
 *
 * Before:
 * ```ts
 * @Component({
 *   // ...
 * })
 * export class FooComponent implements OnDestroy {
 *   private readonly destroy$ = new Subject<void>();
 *
 *   constructor() {
 *     obs$.pipe(takeUntil(this.destroy$)).subscribe(doSideEffect);
 *   }
 *
 *   ngOnDestroy(): void {
 *     this.destroy$.next();
 *     this.destroy$.complete();
 *   }
 * }
 * ```
 *
 * After:
 * ```ts
 * @Component({
 *   // ...
 *   providers: [RxEffects],
 * })
 * export class FooComponent {
 *   constructor(effects: RxEffects) {
 *     effects.register(obs$, doSideEffect);
 *     // OR
 *     effects.register(obs$.pipe(tap(doSideEffect)));
 *     // OR
 *     effects.register(obs$.subscribe(doSideEffect));
 *   }
 * }
 * ```
 *
 * NOTE: Avoid calling register/unregister/subscribe inside the side-effect function.
 */
class RxEffects {
    errorHandler;
    constructor(errorHandler) {
        this.errorHandler = errorHandler;
    }
    static nextId = 0;
    _hooks$ = new Subject();
    observables$ = new Subject();
    // we have to use publish here to make it hot (composition happens without subscriber)
    effects$ = this.observables$.pipe(mergeAll(), share());
    subscription = this.effects$.subscribe();
    onDestroy$ = this._hooks$.pipe(toHook('destroy'));
    destroyers = {};
    register(obsOrSub, fnOrObj) {
        if (obsOrSub instanceof Subscription) {
            this.subscription.add(obsOrSub);
            return;
        }
        const effectId = RxEffects.nextId++;
        const destroy$ = (this.destroyers[effectId] = new Subject());
        const applyBehavior = pipe(mapTo(effectId), takeUntil(destroy$));
        if (fnOrObj != null) {
            this.observables$.next(from(obsOrSub).pipe(
            // ternary expression is to help Typescript infer overloads
            typeof fnOrObj === 'function' ? tap(fnOrObj) : tap(fnOrObj), catchError((err) => {
                this.errorHandler?.handleError(err);
                return EMPTY;
            }), applyBehavior));
        }
        else {
            this.observables$.next(from(obsOrSub).pipe(applyBehavior));
        }
        return effectId;
    }
    /**
     * Imperatively cancel a side-effect while the component is still running.
     *
     * Note that all effects are automatically cancelled when a component is destroyed,
     * so you most often won't need to call this method.
     * @param effectId Effect ID (returned by register method)
     */
    unregister(effectId) {
        this.destroyers[effectId]?.next();
    }
    /**
     * Fires a sideEffect when the instances `OnDestroy` hook is fired.
     *
     * @example
     * effects.registerOnDestroy(mode => localStorage.setItem('colorMode', mode));
     *
     * @param sideEffect
     */
    registerOnDestroy(sideEffect) {
        return this.register(this.onDestroy$, sideEffect);
    }
    /**
     * Operator that unsubscribes based on emission of an registered effect.
     *
     * @NOTICE
     * This operator has to be placed always at the end of the operator chain (before the subscription).
     * Otherwise we may leak as a subsequent operator could instantiate new ongoing Observables which will not get unsubscribed.
     *
     * @example
     * const effectId1 = effects.register(
     *   colorMode$.subscribe(mode => localStorage.setItem('colorMode', mode))
     * );
     *
     * someValue$.pipe(
     *    effect.untilEffect(effectId1)
     * )
     *
     */
    untilEffect(effectId) {
        return (source) => source.pipe(untilDestroyed(this), takeUntil(this.effects$.pipe(filter((eId) => eId === effectId))));
    }
    /**
     * @internal
     */
    ngOnDestroy() {
        this._hooks$.next({ destroy: true });
        this.subscription.unsubscribe();
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: RxEffects, deps: [{ token: i0.ErrorHandler, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: RxEffects });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: RxEffects, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: i0.ErrorHandler, decorators: [{
                    type: Optional
                }] }] });

/**
 * @description
 * Functional way to setup observable based side effects with RxEffects.
 * It's a creation function for RxEffects that destroys itself when the provided
 * `DestroyRef` is destroyed.
 *
 * @example
 * ```ts
 * import { rxEffects } from '@rx-angular/state/effects';
 *
 * \@Component({})
 * export class FooComponent {
 *  const readonly util = inject(Util);
 *  readonly effects = rxEffects(({ register }) => {
 *    register(this.util.windowResize$, () => {
 *      console.log('window was resized');
 *    })
 *  });
 *
 *  ngOnInit() {
 *    this.effects.register(this.util.rotationChanged$, () => {
 *      console.log('viewport rotation changed');
 *    });
 *  }
 * }
 * ```
 *
 * @param {RxEffectsSetupFn} setupFn
 * @returns RxEffects
 *
 * @docsCategory RxEffects
 * @docsPage RxEffects
 *
 */
function rxEffects(setupFn) {
    assertInInjectionContext(rxEffects);
    const errorHandler = inject(ErrorHandler, { optional: true });
    const destroyRef = inject(DestroyRef);
    const runningEffects = [];
    destroyRef.onDestroy(() => runningEffects.forEach((ef) => ef.unsubscribe()));
    /**
     * Subscribe to observables and trigger side effect.
     *
     * @example
     *
     * /@Component({
     *   template: `<button name="save" (click)="save()">Save</button>`
     * })
     * class ListComponent {
     *   private ef = rxEffects(({register}) => {
     *      register(timer(0, this.backupInterval), console.log));
     *   }
     * }
     *
     * @param {SideEffectObservable} obs$ Source observable input
     * @param {SideEffectFnOrObserver} sideEffect Observer object
     *
     * @return {Function} - unregisterFn
     */
    function register(obs$, sideEffect) {
        const observer = typeof sideEffect === 'object'
            ? {
                ...sideEffect,
                // preserve original logic
                error: (e) => {
                    sideEffect.error?.(e);
                    errorHandler?.handleError(e);
                },
            }
            : {
                next: sideEffect,
                error: (e) => errorHandler?.handleError(e),
            };
        const sub = from(obs$).subscribe(observer);
        runningEffects.push(sub);
        return () => sub.unsubscribe();
    }
    /**
     * Register custom cleanup logic.
     *
     * @example
     *
     * /@Component({
     *   template: `<button name="save" (click)="save()">Save</button>`
     * })
     * class ListComponent {
     *   private ef = rxEffects(({onDestroy}) => {
     *      onDestroy(() => console.log('done'));
     *   }
     * }
     *
     * @param {Fn} callback onDestroy callback
     *
     * @return {Fn} unregisterFn
     */
    function onDestroy(callback) {
        return destroyRef.onDestroy(callback);
    }
    const effects = {
        register,
        onDestroy,
    };
    setupFn?.(effects);
    return effects;
}

/**
 * Generated bundle index. Do not edit.
 */

export { RxEffects, rxEffects };
//# sourceMappingURL=state-effects.mjs.map
